<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <title>variadic function in c | NCJ-Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <meta name="keywords" content="CGrammar">
  
  
  
  
  <meta name="description" content="&amp;emsp;&amp;emsp;去年参加MSC的决赛的时候，遇到了关于变参函数的问题。其实这类函数很套路，但是考虑到之后想写的关于宏的一篇文章中有些东西跟变参函数有些类似，而且网上关于变参函数的教程都几乎是千篇一律、不中要害，因此先写一篇关于变参函数的文章，对其使用方法进行探讨。  〇、引言-常规的函数&amp;emsp;&amp;emsp;在C语言中，函数在声明时往往就要指定参数的数量与类型，编译的时候，编译器也会替我">
<meta name="keywords" content="C,Grammar">
<meta property="og:type" content="article">
<meta property="og:title" content="Variadic Function in C">
<meta property="og:url" content="https://ncj.wiki/2019/01/20/2019-01-20_variadic-function/index.html">
<meta property="og:site_name" content="NCJ-Blog">
<meta property="og:description" content="&amp;emsp;&amp;emsp;去年参加MSC的决赛的时候，遇到了关于变参函数的问题。其实这类函数很套路，但是考虑到之后想写的关于宏的一篇文章中有些东西跟变参函数有些类似，而且网上关于变参函数的教程都几乎是千篇一律、不中要害，因此先写一篇关于变参函数的文章，对其使用方法进行探讨。  〇、引言-常规的函数&amp;emsp;&amp;emsp;在C语言中，函数在声明时往往就要指定参数的数量与类型，编译的时候，编译器也会替我">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2019-09-05T13:38:45.730Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Variadic Function in C">
<meta name="twitter:description" content="&amp;emsp;&amp;emsp;去年参加MSC的决赛的时候，遇到了关于变参函数的问题。其实这类函数很套路，但是考虑到之后想写的关于宏的一篇文章中有些东西跟变参函数有些类似，而且网上关于变参函数的教程都几乎是千篇一律、不中要害，因此先写一篇关于变参函数的文章，对其使用方法进行探讨。  〇、引言-常规的函数&amp;emsp;&amp;emsp;在C语言中，函数在声明时往往就要指定参数的数量与类型，编译的时候，编译器也会替我">
  
    <link rel="alternate" href="/atom.xml" title="NCJ-Blog" type="application/atom+xml">
  

  

  <link rel="icon" href="/css/images/mylogo.jpg">
  <link rel="apple-touch-icon" href="/css/images/mylogo.jpg">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt; src:url("css/fonts/FuturaPTBold.otf") format("woff");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt-light; src:url("css/fonts/FuturaPTBook.otf") format("woff");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt-italic; src:url("css/fonts/FuturaPTBookOblique.otf") format("woff");font-weight:400;font-style:italic;}
}

  </style>
  <link rel="stylesheet" href="/css/style.css">

  <script src="/js/jquery-3.1.1.min.js"></script>
  <script src="/js/bootstrap.js"></script>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css">

  
    <link rel="stylesheet" href="/css/dialog.css">
  

  

  
    <link rel="stylesheet" href="/css/header-post.css">
  

  
  
  
    <link rel="stylesheet" href="/css/vdonate.css">
  

</head>
</html>


  <body data-spy="scroll" data-target="#toc" data-offset="50">


  
  <div id="container">
    <div id="wrap">
      
        <header>

    <div id="allheader" class="navbar navbar-default navbar-static-top" role="navigation">
        <div class="navbar-inner">
          
          <div class="container"> 
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
              <span class="sr-only">Toggle navigation</span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>

            
              <a class="brand" style="
                 margin-top: 0px;"  
                href="#" data-toggle="modal" data-target="#myModal" >
                  <img width="124px" height="124px" alt="Hike News" src="/css/images/mylogo.jpg">
              </a>
            
            
            <div class="navbar-collapse collapse">
              <ul class="hnav navbar-nav">
                
                  
                    <li> <a class="main-nav-link" href="/">Home</a> </li>
                  
                  
                
                  
                    <li> <a class="main-nav-link" href="/archives">Archives</a> </li>
                  
                  
                
                  
                    <li> <a class="main-nav-link" href="https://ncj.wiki/Projects_Show">Projects</a> </li>
                  
                  
                
                  
                    <li> <a class="main-nav-link" href="/tags">Tags</a> </li>
                  
                  
                
                  
                    <li> <a class="main-nav-link" href="/about">About</a> </li>
                  
                  
                
                  <li><div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="Type something..." />
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Posts',
            PAGES: 'Pages',
            CATEGORIES: 'Categories',
            TAGS: 'Tags',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div></li>
            </div>
          </div>
                
      </div>
    </div>

</header>



      
            
      <div id="content" class="outer">
        
          <section id="main" style="float:none;"><article id="post-2019-01-20_variadic-function" style="width: 75%; float:left;" class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" class="article-title" itemprop="name">
      Variadic Function in C
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2019/01/20/2019-01-20_variadic-function/" class="article-date">
	  <time datetime="2019-01-20T05:22:41.000Z" itemprop="datePublished">2019-01-20</time>
	</a>

      
      
      

      </br></br>
      WordCount: 
      <span class="post-count">4.2k</span>
      Min2Read: 
      <span class="post-count">17</span>
      <!-- <span class="post-count">33.3k</span> -->
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>&emsp;&emsp;去年参加MSC的决赛的时候，遇到了关于变参函数的问题。其实这类函数很套路，但是考虑到之后想写的关于宏的一篇文章中有些东西跟变参函数有些类似，而且网上关于变参函数的教程都几乎是千篇一律、不中要害，因此先写一篇关于变参函数的文章，对其使用方法进行探讨。</p>
<hr>
<h1 id="〇、引言-常规的函数"><a href="#〇、引言-常规的函数" class="headerlink" title="〇、引言-常规的函数"></a>〇、引言-常规的函数</h1><p>&emsp;&emsp;在C语言中，函数在声明时往往就要指定参数的数量与类型，编译的时候，编译器也会替我们检查，看函数调用有无问题。</p>
<p>&emsp;&emsp;例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	func(<span class="number">100</span>); <span class="comment">// 实参数目不对</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;此时编译器就会报错：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="function">error: <span class="title">too</span> <span class="title">few</span> <span class="title">arguments</span> <span class="title">to</span> <span class="title">function</span> '<span class="title">func</span>'</span></span><br><span class="line"><span class="function"><span class="title">func</span>(100);</span></span><br><span class="line"><span class="function">^</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;再如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span>* a; </span><br><span class="line">	func(a, <span class="number">100</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;此时编译器不会报错（at least for GCC），但是会给出一个Warning：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="function">warning: <span class="title">passing</span> <span class="title">argument</span> 1 <span class="title">of</span> '<span class="title">func</span>' <span class="title">makes</span> <span class="title">integer</span> <span class="title">from</span> <span class="title">pointer</span> <span class="title">without</span> <span class="title">a</span> <span class="title">cast</span></span></span><br><span class="line"><span class="function">  <span class="title">func</span>(<span class="title">a</span>, 100);</span></span><br><span class="line"><span class="function">       ^</span></span><br><span class="line"><span class="function"><span class="title">note</span>: <span class="title">expected</span> '<span class="title">int</span>' <span class="title">but</span> <span class="title">argument</span> <span class="title">is</span> <span class="title">of</span> <span class="title">type</span> '<span class="title">int</span> *'</span></span><br><span class="line"><span class="function"> <span class="title">int</span> <span class="title">func</span>(<span class="title">int</span> <span class="title">i</span>, <span class="title">int</span> <span class="title">j</span>)</span></span><br><span class="line"><span class="function">     ^</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在这里我是故意用的一个指针，如果你用的是<code>double</code>或者<code>char</code>的话，连warning都不会出现，到时候一个强制类型转化塞给<code>func()</code>。</p>
<p>&emsp;&emsp;于是，我们大部分时候接触到的函数就都是这种参数个数、类型都不可变的函数了。</p>
<p>&emsp;&emsp;但其实有一个函数，我们从Hello World就开始用了，而且几乎目前的每个程序里都要用到，而它其实是一个变参函数。</p>
<h1 id="一、printf-scanf-就是变参函数！"><a href="#一、printf-scanf-就是变参函数！" class="headerlink" title="一、printf() scanf() 就是变参函数！"></a>一、<code>printf()</code> <code>scanf()</code> 就是变参函数！</h1><p>&emsp;&emsp;没错，C 语言中最常用的可变参数函数例子其实就是<code>printf()</code>和 <code>scanf()</code>。仔细想想，每次你在调用这两个函数的时候，其后面的参数个数以及类型是不是的确在变化？</p>
<p>&emsp;&emsp;为了进一步了解其实现的机制，我们来看看这两个函数的函数原型。（以TDM-GCC为例）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * __restrict__ _Format,...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">scanf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * __restrict__ _Format,...)</span> __MINGW_ATTRIB_DEPRECATED_SEC_WARN</span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;其中的<code>...</code>就是变参函数中可变参数部分的声明。</p>
<h1 id="二、变参函数的特点"><a href="#二、变参函数的特点" class="headerlink" title="二、变参函数的特点"></a>二、变参函数的特点</h1><p>&emsp;&emsp;我们来就这两个经典的函数，简要分析一下变参函数的特点。</p>
<h2 id="1）一定要有固定数量的强制参数（mandatory-argument）"><a href="#1）一定要有固定数量的强制参数（mandatory-argument）" class="headerlink" title="1）一定要有固定数量的强制参数（mandatory argument）"></a>1）一定要有固定数量的强制参数（mandatory argument）</h2><p>&emsp;&emsp;<strong>变参函数必须至少有一个强制参数。</strong></p>
<p>&emsp;&emsp;在这两个函数中，它体现为一个格式化字符串——<code>const char * __restrict__ _Format</code>。</p>
<h2 id="2）省略号（…）代表可选参数"><a href="#2）省略号（…）代表可选参数" class="headerlink" title="2）省略号（…）代表可选参数"></a>2）省略号（…）代表可选参数</h2><p>&emsp;&emsp;在格式化字符串之后，紧跟着的是一个逗号和三个点构成的省略号。这个省略号代表的就是可选参数。可选参数的类型可以变化。</p>
<h2 id="3）参数列表的格式是强制性参数在前、可选参数在后"><a href="#3）参数列表的格式是强制性参数在前、可选参数在后" class="headerlink" title="3）参数列表的格式是强制性参数在前、可选参数在后"></a>3）参数列表的格式是强制性参数在前、可选参数在后</h2><p>&emsp;&emsp;如果我强行在可选参数之后再添加一个强制参数，比如下面的一波操作：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumplus</span><span class="params">(<span class="keyword">int</span> count, ..., <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;编译会报错：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="function">error: <span class="title">expected</span> ')' <span class="title">before</span> ',' <span class="title">token</span></span></span><br><span class="line"><span class="function"> <span class="title">int</span> <span class="title">sumplus</span>(<span class="title">int</span> <span class="title">count</span>, ..., <span class="title">int</span> <span class="title">m</span>) </span></span><br><span class="line"><span class="function">                           ^</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;一定会有人说，可选参数在最后不应该是天经地义的吗？但是到后面你就会发现我这番尝试并不是空穴来风。</p>
<h2 id="4）编译器和函数并不知道可选参数有多少个"><a href="#4）编译器和函数并不知道可选参数有多少个" class="headerlink" title="4）编译器和函数并不知道可选参数有多少个"></a>4）编译器和函数并不知道可选参数有多少个</h2><p>&emsp;&emsp;肯定又会有人说，<code>printf()</code> <code>scanf()</code> 不是可以按照后面参数的要求输出、输入吗？确实可以，但是它们真的不知道自己后面有几个参数。</p>
<p>&emsp;&emsp;实验为证：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="number">100</span>, <span class="number">200</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;编译通过：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">Compilation results...</span><br><span class="line">--------</span><br><span class="line">- Errors: <span class="number">0</span></span><br><span class="line">- Warnings: <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;运行试试？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">100</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;杠精会说：嗯，那是<code>printf()</code>自动帮你把后面多的参数扔掉了。</p>
<p>&emsp;&emsp;Really?</p>
<p>&emsp;&emsp;依然以实验为证：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d %d %d %d %d %d\n"</span>, <span class="number">100</span>, <span class="number">200</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;依然编译通过：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">Compilation results...</span><br><span class="line">--------</span><br><span class="line">- Errors: <span class="number">0</span></span><br><span class="line">- Warnings: <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;再运行试试？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">100 200 17 42 4199400 0</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;开始乱码了……</p>
<p>&emsp;&emsp;这就已经充分说明编译器和函数完全不知道你给它了多少给参数。它们完全不知道这些，只是按照一定的规则在试图读取这些可变的参数。那规则是什么呢？答案马上揭晓。</p>
<h1 id="三、实现变参函数的方法"><a href="#三、实现变参函数的方法" class="headerlink" title="三、实现变参函数的方法"></a>三、实现变参函数的方法</h1><h2 id="0）搬运过来的题目背景介绍"><a href="#0）搬运过来的题目背景介绍" class="headerlink" title="0）搬运过来的题目背景介绍"></a>0）搬运过来的题目背景介绍</h2><blockquote>
<p>&emsp;&emsp;在 C 调用约定下我们可以使用 <code>va</code> 系列宏来轻松的实现一些变参函数，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt; <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line">&gt; <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> count, ...)</span> </span></span><br><span class="line">&gt; &#123;</span><br><span class="line">&gt;    	va_list args;</span><br><span class="line">&gt;    	va_start(args, count);</span><br><span class="line">&gt;    	<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">&gt;    	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) </span><br><span class="line">&gt;    	&#123;</span><br><span class="line">&gt;    		<span class="keyword">int</span> val = va_arg(args, <span class="keyword">int</span>);</span><br><span class="line">&gt;    		res += val;</span><br><span class="line">&gt;    	&#125;</span><br><span class="line">&gt;    	va_end(args);</span><br><span class="line">&gt;    	<span class="keyword">return</span> res;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>&emsp;&emsp;代码本身很简单，这里稍微解释。</p>
<p>&emsp;&emsp;<code>va_list args;</code> 定义一个指向可变参数列表的指针</p>
<p>&emsp;&emsp;<code>va_start(args, count);</code> 使参数列表指针指向函数参数 <code>count</code></p>
<p>&emsp;&emsp;<code>va_arg(args, int)</code> 把参数列表指针当前所指位置以类型 <code>int</code> 读取出来并移动参数列表指针</p>
<p>&emsp;&emsp;<code>va_end(args)</code> 清空参数列表。<code>va_start</code> 和 <code>va_end</code> 必须一一对应 。”每次调用<code>va_start()</code> / <code>va_copy()</code>后，必须得有相应的<code>va_end()</code>与之匹配。参数指针可以在参数列表中随意地来回移动，但必须在<code>va_start()</code> … <code>va_end()</code>之内</p>
<p>&emsp;&emsp;当然大家可以发现这种形式的可变参数函数是非常危险的，<code>va_arg</code> 基本就是强制类型转换，而且读取的参数个数也只能通过用户输入来确认，很容易出现访问参数越界的情况。同时 <code>va_arg</code> <strong>取出的参数类型和实际传入的类型不一致，或是访问最后一个参数之后的参数</strong>是未定义行为，在不同平台、不同编译器实现下的结果可能不完全相同，所以在使用这些函数的时候也请大家务必注意参数的个数和类型问题。</p>
</blockquote>
<p>&emsp;&emsp;这段话不是我写的。我是直接从决赛题的题目背景里搬过来的。其实它讲的已经比较清楚了，网上的各种教程基本上都是这段代码和解释。但是，有几点想与大家探讨一下。</p>
<h2 id="1）关于可变参数的读取个数的问题"><a href="#1）关于可变参数的读取个数的问题" class="headerlink" title="1）关于可变参数的读取个数的问题"></a>1）关于可变参数的读取个数的问题</h2><p>&emsp;&emsp;最后一段话中其实解释了这个问题：<strong>读取的参数个数也只能通过用户输入来确认</strong>！</p>
<p>&emsp;&emsp;这就是为什么前面<code>printf()</code>的例子中没有报错的原因了——编译器不会检查函数的参数个数。<code>printf()</code>完全是依赖格式化字符串中的种种要求来读取后面的可变参数的。而这又引发了另一个问题，何时停止读取？——依然依赖格式化字符串中的要求。因此，当格式化字符串中有要求输出、而后面的可变参数中并没有对应参数时，就出现了<strong>访问参数越界的情况</strong>——这也正是前面输出乱码的原因。</p>
<h2 id="2）关于va-start"><a href="#2）关于va-start" class="headerlink" title="2）关于va_start()"></a>2）关于<code>va_start()</code></h2><blockquote>
<p><code>va_start(args, count);</code> 使参数列表指针指向函数参数 <code>count</code></p>
</blockquote>
<p>&emsp;&emsp;这句话这么说其实不太合适。（刚刚还说这段话讲得比较清楚……，就当是出题人美中不足吧）</p>
<p>&emsp;&emsp;要解释清楚<code>va_start(args, count);</code>，我们还是来做实验为好。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumplus</span><span class="params">(<span class="keyword">int</span> count, <span class="keyword">int</span> m, ...)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    va_list args;</span><br><span class="line">    va_start(args, count);</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> val = va_arg(args, <span class="keyword">int</span>);</span><br><span class="line">        res += val;</span><br><span class="line">    &#125;</span><br><span class="line">    va_end(args);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = sumplus(<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">100</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这段代码编译会有warning：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="function">warning: <span class="title">second</span> <span class="title">parameter</span> <span class="title">of</span> '<span class="title">va_start</span>' <span class="title">not</span> <span class="title">last</span> <span class="title">named</span> <span class="title">argument</span> [-<span class="title">Wvarargs</span>]</span></span><br><span class="line"><span class="function">     <span class="title">va_start</span>(<span class="title">args</span>, <span class="title">count</span>);</span></span><br><span class="line"><span class="function">     ^</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;运行试试？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">104</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这就说明编译之后，参数还是从 <code>...</code> 的位置开始读取的。（应该是编译器帮忙优化的，自动将指针挪到last named argument那里了）</p>
<p>&emsp;&emsp;我们来看看GCC中<code>va_start()</code>的声明。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> va_start(v,l)	__builtin_va_start(v,l)</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;emmm，意义不大……</p>
<p>&emsp;&emsp;再看看VC6.0中的声明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> va_start(ap,v) ( ap = (va_list)&amp;v + _INTSIZEOF(v) )</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;看来这是将第一个可选参数的地址赋值给<code>ap</code>。（至少在VC6.0里面是这样的）</p>
<p>&emsp;&emsp;因此<code>va_start()</code>的作用是使参数列表指针指向第一个可选参数。</p>
<p>&emsp;&emsp;引用一下<a href="http://www.cplusplus.com/reference/cstdarg/va_start/" target="_blank" rel="noopener">cplusplus</a>对于<code>va_start()</code>的介绍来证明和完善这一观点。</p>
<blockquote>
<p><strong>va_start</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt; <span class="function"><span class="keyword">void</span> <span class="title">va_start</span> <span class="params">(va_list ap, paramN)</span></span>;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>Initialize a variable argument list</p>
<p>Initializes ap to retrieve the additional arguments after parameter paramN.</p>
<p>A function that invokes <a href="http://www.cplusplus.com/va_start" target="_blank" rel="noopener">va_start</a>, shall also invoke <a href="http://www.cplusplus.com/va_end" target="_blank" rel="noopener">va_end</a> before it returns.</p>
<p><em>Parameters</em></p>
<ul>
<li>ap</li>
</ul>
<p>Uninitialized object of type <a href="http://www.cplusplus.com/va_list" target="_blank" rel="noopener">va_list</a>. After the call, it carries the information needed to retrieve the additional arguments using <a href="http://www.cplusplus.com/va_arg" target="_blank" rel="noopener">va_arg</a>. If ap has already been passed as first argument to a previous call to <a href="http://www.cplusplus.com/va_start" target="_blank" rel="noopener">va_start</a> or <a href="http://www.cplusplus.com/va_copy" target="_blank" rel="noopener">va_copy</a>, it shall be passed to <a href="http://www.cplusplus.com/va_end" target="_blank" rel="noopener">va_end</a> before calling this function. </p>
<ul>
<li>paramN</li>
</ul>
<p>Name of the last named parameter in the function definition. The arguments extracted by subsequent calls to <a href="http://www.cplusplus.com/va_arg" target="_blank" rel="noopener">va_arg</a> are those after paramN.</p>
</blockquote>
<h2 id="3）关于va-arg"><a href="#3）关于va-arg" class="headerlink" title="3）关于va_arg()"></a>3）关于<code>va_arg()</code></h2><blockquote>
<p>C 语言参数传递时有自动类型提升，char 会被 cast 成 int 再传过去，所以在拿的时候也得拿一个 int</p>
</blockquote>
<p>&emsp;&emsp;什么意思呢？一会看到实例就明白了。简单说，就是提取可变参数时，所提取的变量类型不一定与其实际类型一致，比如<code>char</code>就需要以<code>int</code>类型的方式读取。</p>
<h2 id="4）关于va-end"><a href="#4）关于va-end" class="headerlink" title="4）关于va_end()"></a>4）关于<code>va_end()</code></h2><blockquote>
<p>参数指针可以在参数列表中随意地来回移动，但必须在<code>va_start()</code> … <code>va_end()</code>之内</p>
</blockquote>
<p>&emsp;&emsp;还记得我在前面提到过的一个看似无用的实验吗？<code>int sumplus(int count, ..., int m)</code>并不能通过编译。但是我为什么会想到去尝试？理由很简单，既然 <code>va_start()</code> 和 <code>va_end()</code> 是成对出现的，那么是否会存在这么一种参数结构，先有几个强制参数，再是可变参数，最后又是几个强制参数，中间调用可变参数时使用 <code>va_start()</code> 和 <code>va_end()</code> ？实验证明这是不允许的，可变参数就是必须放在最后，这是规定与要求。</p>
<p> &emsp;&emsp;可是既然如此，那<code>va_end()</code>意义何在？可以不调用吗？</p>
<p>&emsp;&emsp;老规矩，先做个实验看看：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumplus</span><span class="params">(<span class="keyword">int</span> count, ...)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    va_list args;</span><br><span class="line">    va_start(args, count);</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> val = va_arg(args, <span class="keyword">int</span>);</span><br><span class="line">        res += val;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    va_end(args);</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;编译通过：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">Compilation results...</span><br><span class="line">--------</span><br><span class="line">- Errors: <span class="number">0</span></span><br><span class="line">- Warnings: <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;运行也没毛病……</p>
<p>&emsp;&emsp;所以，真的可以省？</p>
<p>&emsp;&emsp;几经周折，在网上找到这么一篇<a href="http://www.cppblog.com/ownwaterloo/archive/2009/04/21/is_va_end_necessary.html" target="_blank" rel="noopener">文章</a>（这是原作者的文章，CSDN上面的是转载的，好在还注明了原文地址），建议大家去看看。我这里只引用其中的一部分。</p>
<h3 id="1-不调用可能导致程序崩溃"><a href="#1-不调用可能导致程序崩溃" class="headerlink" title="1.不调用可能导致程序崩溃"></a>1.不调用可能导致程序崩溃</h3><blockquote>
<p>&emsp;&emsp;从一个使用过va_start()的函数中退出之前，<strong>必须</strong>调用一次va_end()。<br>&emsp;&emsp;这是因为va_start<strong>可能</strong>以某种方式<strong>修改了堆栈</strong>，这种修改可能导致<strong>返回无法完成</strong>，va_end()能将有关的修改复原。<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;——《C++程序设计语言》 第3版、特别版， p139</p>
</blockquote>
<h3 id="2-不调用可能导致内存泄漏"><a href="#2-不调用可能导致内存泄漏" class="headerlink" title="2.不调用可能导致内存泄漏"></a>2.不调用可能导致内存泄漏</h3><blockquote>
<p>&emsp;&emsp;我们务必记住，在使用完va_list变量后一定要调用宏va_end。<br>&emsp;&emsp;v在<strong>大多数</strong>C实现上，调用va_end与<strong>否并无区别</strong>。<br>&emsp;&emsp;但是，<strong>某些版本</strong>的va_start宏为了方便对va_list的遍历，就给参数列表<strong>动态分配内存</strong>。<br>&emsp;&emsp;这样一种C实现很可能利用va_end宏来释放此前动态分配的内存；<br>&emsp;&emsp;如果忘记调用宏va_end，最后得到的程序可能在某些机型上没有问题，而在另一些机型上则发生“<strong>内存泄露</strong>”。<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;——《C陷阱与缺陷》， p161</p>
</blockquote>
<h3 id="3-还是不想调用？……"><a href="#3-还是不想调用？……" class="headerlink" title="3.还是不想调用？……"></a>3.还是不想调用？……</h3><blockquote>
<p>  …… 最后，<strong>必须</strong>在函数返回之前<strong>调用</strong>va_end，以完成一些必要的<strong>清理</strong>工作。<br>  &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;——《C程序设计语言》 第2版， p137</p>
<p>  ……在所有参数处理完毕后， 且在<strong>退出函数f之前</strong>，<strong>必须调用宏va_end一次</strong> ……<br>  &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;——《C程序设计语言》 第2版， p232  </p>
</blockquote>
<p>&emsp;&emsp;插句题外话：<strong>按照规矩办事，其实想得比你重要！</strong>看看中国那稀烂的安卓生态吧，不多说了……</p>
<h1 id="四、自己实现printf-（决赛原题）"><a href="#四、自己实现printf-（决赛原题）" class="headerlink" title="四、自己实现printf()（决赛原题）"></a>四、自己实现<code>printf()</code>（决赛原题）</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote>
<p>这道题需要你实现一个简单的 <code>printf</code> ，接受一个格式化字符串和若干参数，将结果打印至标准输出。</p>
<p>满足：</p>
<ol>
<li>使用 <code>&#39;$&#39;</code> 作为转义字符，在需要输出 <code>&#39;$&#39;</code> 字符的时候重复一次 <code>&#39;$&#39;</code> , 其它情况下视为输出对应类型的参数</li>
<li>支持 <code>$d</code> 输出 32 位整数(<code>int</code>)， <code>$s</code> 输出字符串(<code>char*</code>)直至 <code>&#39;\0&#39;</code> ，<code>$f</code> 输出双精度浮点数 (<code>double</code>), 保留 6 位小数 , <code>$c</code> 输出单个字符 (<code>char</code>)，保证输入合法</li>
<li>返回其中打印的字符个数</li>
<li>保证 <code>&#39;$&#39;</code> 后不会出现上述提及情况以外的字符</li>
</ol>
<h3 id="函数接口定义"><a href="#函数接口定义" class="headerlink" title="函数接口定义"></a>函数接口定义</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt; <span class="function"><span class="keyword">int</span> <span class="title">simple_printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* fmt, ...)</span></span>;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>其中 <code>fmt</code> 为传入的格式化字符串，<code>...</code> 为传入的其它参数，返回输出的字符串长度</p>
<h3 id="裁判测试程序样例"><a href="#裁判测试程序样例" class="headerlink" title="裁判测试程序样例"></a>裁判测试程序样例</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt; <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="function"><span class="keyword">int</span> <span class="title">simple_printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* fmt, ...)</span></span>;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt;  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, simple_printf(<span class="string">"123 "</span>));</span><br><span class="line">&gt;  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, simple_printf(<span class="string">"$$ "</span>));</span><br><span class="line">&gt;  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, simple_printf(<span class="string">"$d "</span>, <span class="number">123</span>));</span><br><span class="line">&gt;  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, simple_printf(<span class="string">"$c "</span>, <span class="string">'1'</span>));</span><br><span class="line">&gt;  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, simple_printf(<span class="string">"$s "</span>, <span class="string">"123"</span>));</span><br><span class="line">&gt;  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, simple_printf(<span class="string">"$f "</span>, <span class="number">123.4</span>));</span><br><span class="line">&gt;  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">/**</span></span><br><span class="line"><span class="comment">&gt; *	your code here</span></span><br><span class="line"><span class="comment">&gt; **/</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>保证单次调用输出的长度小于 4096，输出的浮点数保留 6 位小数</p>
<h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h3><p>没有输入</p>
<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; 123 4</span><br><span class="line">&gt; $ 2</span><br><span class="line">&gt; 123 4</span><br><span class="line">&gt; 1 2</span><br><span class="line">&gt; 123 4</span><br><span class="line">&gt; 123.400000 11</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>&emsp;&emsp;虽然我当时一遍就AC了，但是做复杂了（比赛时没有注意到<code>printf()</code>返回值就是打印的字符的个数，自己还单独实现了这个功能…），而且代码也只是能跑而已（比赛…时间很紧……），可读性很差，所以借这个机会重新整理一下好了。</p>
<h2 id="AC代码（标程改编）"><a href="#AC代码（标程改编）" class="headerlink" title="AC代码（标程改编）"></a>AC代码（标程改编）</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">simple_printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	va_list args;</span><br><span class="line">	va_start(args, fmt);</span><br><span class="line">	<span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (*fmt != <span class="string">'\0'</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (*fmt != <span class="string">'$'</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">putchar</span>(*fmt);</span><br><span class="line">			fmt++;</span><br><span class="line">			counter++;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		fmt++;</span><br><span class="line">		<span class="keyword">if</span> (*fmt == <span class="string">'d'</span>)</span><br><span class="line">		&#123; <span class="comment">// integer</span></span><br><span class="line">			<span class="keyword">int</span> int_val = va_arg(args, <span class="keyword">int</span>);</span><br><span class="line">			counter += <span class="built_in">printf</span>(<span class="string">"%d"</span>, int_val);</span><br><span class="line">			fmt++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (*fmt == <span class="string">'f'</span>)</span><br><span class="line">		&#123; <span class="comment">// double</span></span><br><span class="line">			<span class="keyword">double</span> float_val = va_arg(args, <span class="keyword">double</span>);</span><br><span class="line">			counter += <span class="built_in">printf</span>(<span class="string">"%lf"</span>, float_val);</span><br><span class="line">			fmt++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (*fmt == <span class="string">'s'</span>)</span><br><span class="line">		&#123; <span class="comment">// char*</span></span><br><span class="line">			<span class="keyword">char</span> *str = va_arg(args, <span class="keyword">char</span> *);</span><br><span class="line">			counter += <span class="built_in">printf</span>(<span class="string">"%s"</span>, str);</span><br><span class="line">			fmt++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (*fmt == <span class="string">'c'</span>)</span><br><span class="line">		&#123; <span class="comment">// char</span></span><br><span class="line">			<span class="keyword">char</span> cha_val = va_arg(args, <span class="keyword">int</span>);</span><br><span class="line">			counter += <span class="number">1</span>;</span><br><span class="line">			<span class="built_in">putchar</span>(cha_val);</span><br><span class="line">			fmt++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (*fmt == <span class="string">'$'</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			fmt++;</span><br><span class="line">			<span class="built_in">putchar</span>(<span class="string">'$'</span>);</span><br><span class="line">			counter += <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	va_end(args);</span><br><span class="line">	<span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;有两点需要注意:</p>
<p>&emsp;&emsp;1. C 语言参数传递时有自动类型提升，char 会被 cast 成 int 再传过去，所以在拿的时候也得拿一个 int</p>
<p>&emsp;&emsp;这就是刚才提到的关于<code>va_arg()</code>的实例。注意到这样一段代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (*fmt == <span class="string">'c'</span>)</span><br><span class="line">&#123; <span class="comment">// char</span></span><br><span class="line">    <span class="keyword">char</span> cha_val = va_arg(args, <span class="keyword">int</span>);</span><br><span class="line">    counter += <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">putchar</span>(cha_val);</span><br><span class="line">    fmt++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在这里，<code>char</code>需要用<code>int</code>来读取。（<code>char cha_val = va_arg(args, int)</code>)</p>
<p>&emsp;&emsp;不过这个很容易发现，因为如果你用<code>char</code>来读取：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (*fmt == <span class="string">'c'</span>)</span><br><span class="line">&#123; <span class="comment">// char</span></span><br><span class="line">    <span class="keyword">char</span> cha_val = va_arg(args, <span class="keyword">char</span>);</span><br><span class="line">    counter += <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">putchar</span>(cha_val);</span><br><span class="line">    fmt++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;编译会有warning…</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="function">warning: '<span class="title">char</span>' <span class="title">is</span> <span class="title">promoted</span> <span class="title">to</span> '<span class="title">int</span>' <span class="title">when</span> <span class="title">passed</span> <span class="title">through</span> '...'</span></span><br><span class="line"><span class="function">    <span class="title">char</span> <span class="title">cha_val</span> = <span class="title">va_arg</span>(<span class="title">args</span>, <span class="title">char</span>);</span></span><br><span class="line"><span class="function">                                ^</span></span><br><span class="line"><span class="function"><span class="title">note</span>: (<span class="title">so</span> <span class="title">you</span> <span class="title">should</span> <span class="title">pass</span> '<span class="title">int</span>' <span class="title">not</span> '<span class="title">char</span>' <span class="title">to</span> '<span class="title">va_arg</span>')</span></span><br><span class="line"><span class="function"><span class="title">note</span>: <span class="title">if</span> <span class="title">this</span> <span class="title">code</span> <span class="title">is</span> <span class="title">reached</span>, <span class="title">the</span> <span class="title">program</span> <span class="title">will</span> <span class="title">abort</span></span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;运行起来真的abort了…（不同编译器、不同编译选项可能结果不同）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">123 4</span><br><span class="line">$ 2</span><br><span class="line">123 4</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;2. 这基本上就是<code>printf()</code>的实现原理了，只不过<code>printf()</code>还可以支持更多的格式化字符串的要求。这也应证了我前面说的：编译器和函数完全不知道你给它了多少给参数。它们完全不知道这些，只是按照一定的规则在试图读取这些可变的参数。</p>
<p>&emsp;&emsp;<code>printf()</code>依照的，就是格式化字符串。</p>
<hr>
<p>&emsp;&emsp;关于C语言中变参函数的介绍差不多就这些了。自认为是网上最翔实的一篇了，主要还是将自己摸索的过程体现出来。过几天我会再写一篇关于C语言宏的文章，主要谈谈可变参数的宏函数以及宏运算符到底有什么用。希望这两篇文章能对读者有所帮助。</p>

      
    </div>
    <footer class="article-footer">
      
        <div id="donation_div"></div>

<script src="/js/vdonate.js"></script>
<script>
var a = new Donate({
  title: '如果觉得我的文章对您有用，请随意打赏。您的支持将鼓励我继续创作!', // 可选参数，打赏标题
  btnText: 'Donate', // 可选参数，打赏按钮文字
  el: document.getElementById('donation_div'),
  wechatImage: 'https://gitee.com/iamncj/Picture_Bed/raw/master/Money_Tips/Wechat_QR.PNG',
  alipayImage: 'https://gitee.com/iamncj/Picture_Bed/raw/master/Money_Tips/Wechat_QR.PNG'
});
</script>
      
      
      <div>
        <ul class="post-copyright">
          <li class="post-copyright-author">
          <strong>Post author:  </strong>NCJ</a>
          </li>
          <li class="post-copyright-link">
          <strong>Post link:  </strong>
          <a href="/2019/01/20/2019-01-20_variadic-function/" target="_blank" title="Variadic Function in C">https://ncj.wiki/2019/01/20/2019-01-20_variadic-function/</a>
          </li>
          <li class="post-copyright-license">
            <strong>Copyright Notice:   </strong>
            All articles in this blog are licensed under <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">CC BY-NC-ND 4.0</a>
            unless stating additionally.
          </li>
         
        </ul>
<div>

      
      
        
	<div id="gitalk-container"></div>
	<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
	<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.11.1/js/md5.min.js"></script>
	<script type="text/javascript">
	  var gitalk = new Gitalk({
		clientID: '8b4a7d69678c89c26361',
		clientSecret: 'eb62487ca685a8b1ceda674607520d66ef342cbd',
		repo: 'blog-comments',
		owner: 'iamNCJ',
		admin: 'iamNCJ',
		id: md5(location.pathname),
		language: 'en',
		perPage: 15,
		pagerDirection: 'last',
		createIssueManually: 'false',
		distractionFreeMode: 'false'
	  });
  
	  gitalk.render('gitalk-container')
	</script>
  
  
      
      
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/">C</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Grammar/">Grammar</a></li></ul>

      

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/02/19/2019-02-19_Macro/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          C语言的宏运算符
        
      </div>
    </a>
  
  
    <a href="/2019/01/15/2019-01-15_calculus-review/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Calculus Review</div>
    </a>
  
</nav>

  
</article>

<!-- Table of Contents -->

  <aside id="toc-sidebar">
    <div id="toc" class="toc-article">
    <strong class="toc-title">Contents</strong>
    
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#〇、引言-常规的函数"><span class="nav-number">1.</span> <span class="nav-text">〇、引言-常规的函数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#一、printf-scanf-就是变参函数！"><span class="nav-number">2.</span> <span class="nav-text">一、printf() scanf() 就是变参函数！</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#二、变参函数的特点"><span class="nav-number">3.</span> <span class="nav-text">二、变参函数的特点</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1）一定要有固定数量的强制参数（mandatory-argument）"><span class="nav-number">3.1.</span> <span class="nav-text">1）一定要有固定数量的强制参数（mandatory argument）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2）省略号（…）代表可选参数"><span class="nav-number">3.2.</span> <span class="nav-text">2）省略号（…）代表可选参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3）参数列表的格式是强制性参数在前、可选参数在后"><span class="nav-number">3.3.</span> <span class="nav-text">3）参数列表的格式是强制性参数在前、可选参数在后</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4）编译器和函数并不知道可选参数有多少个"><span class="nav-number">3.4.</span> <span class="nav-text">4）编译器和函数并不知道可选参数有多少个</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#三、实现变参函数的方法"><span class="nav-number">4.</span> <span class="nav-text">三、实现变参函数的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#0）搬运过来的题目背景介绍"><span class="nav-number">4.1.</span> <span class="nav-text">0）搬运过来的题目背景介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1）关于可变参数的读取个数的问题"><span class="nav-number">4.2.</span> <span class="nav-text">1）关于可变参数的读取个数的问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2）关于va-start"><span class="nav-number">4.3.</span> <span class="nav-text">2）关于va_start()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3）关于va-arg"><span class="nav-number">4.4.</span> <span class="nav-text">3）关于va_arg()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4）关于va-end"><span class="nav-number">4.5.</span> <span class="nav-text">4）关于va_end()</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-不调用可能导致程序崩溃"><span class="nav-number">4.5.1.</span> <span class="nav-text">1.不调用可能导致程序崩溃</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-不调用可能导致内存泄漏"><span class="nav-number">4.5.2.</span> <span class="nav-text">2.不调用可能导致内存泄漏</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-还是不想调用？……"><span class="nav-number">4.5.3.</span> <span class="nav-text">3.还是不想调用？……</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#四、自己实现printf-（决赛原题）"><span class="nav-number">5.</span> <span class="nav-text">四、自己实现printf()（决赛原题）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述"><span class="nav-number">5.1.</span> <span class="nav-text">题目描述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#函数接口定义"><span class="nav-number">5.1.1.</span> <span class="nav-text">函数接口定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#裁判测试程序样例"><span class="nav-number">5.1.2.</span> <span class="nav-text">裁判测试程序样例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#输入样例"><span class="nav-number">5.1.3.</span> <span class="nav-text">输入样例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#输出样例"><span class="nav-number">5.1.4.</span> <span class="nav-text">输出样例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AC代码（标程改编）"><span class="nav-number">5.2.</span> <span class="nav-text">AC代码（标程改编）</span></a></li></ol></li></ol>
    
    </div>
  </aside>

</section>
        
      </div>
      
      <footer id="footer">
  

  <div class="container">
      	<div class="row">
	      <p> Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> </p>
	      <p id="copyRightEn">Copyright &copy; 2018 - 2020 NCJ All Rights Reserved. <a href="http://www.beian.miit.gov.cn" target="_blank">鄂ICP备19013260号</a></p>
	      
		</div>

		
  </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");
    var allheader = document.getElementById("allheader");

    wrapdiv.style.minHeight = document.body.offsetHeight + "px";
    if (allheader != null) {
      contentdiv.style.minHeight = document.body.offsetHeight - allheader.offsetHeight - document.getElementById("footer").offsetHeight + "px";
    } else {
      contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("footer").offsetHeight + "px";
    }
</script>
    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/categories" class="mobile-nav-link">Categories</a>
  
    <a href="/tags" class="mobile-nav-link">Tags</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav> -->
    <!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/scripts.js"></script>




  <script src="/js/dialog.js"></script>














  </div>

  <div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true" style="display: none;">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h2 class="modal-title" id="myModalLabel">设置</h2>
      </div>
      <hr style="margin-top:0px; margin-bottom:0px; width:80%; border-top: 3px solid #000;">
      <hr style="margin-top:2px; margin-bottom:0px; width:80%; border-top: 1px solid #000;">


      <div class="modal-body">
          <div style="margin:6px;">
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseOne" onclick="javascript:setFontSize();" aria-expanded="true" aria-controls="collapseOne">
              正文字号大小
            </a>
          </div>
          <div id="collapseOne" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingOne">
          <div class="panel-body">
            您已调整页面字体大小
          </div>
        </div>
      


          <div style="margin:6px;">
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseTwo" onclick="javascript:setBackground();" aria-expanded="true" aria-controls="collapseTwo">
              夜间护眼模式
            </a>
        </div>
          <div id="collapseTwo" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingTwo">
          <div class="panel-body">
            夜间模式已经开启，再次单击按钮即可关闭 
          </div>
        </div>

        <div>
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseThree" aria-expanded="true" aria-controls="collapseThree">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关 于&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</a>
        </div>
         <div id="collapseThree" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingThree">
          <div class="panel-body">
            NCJ-Blog
          </div>
          <div class="panel-body">
            Copyright © 2020 NCJ All Rights Reserved.
          </div>
        </div>
      </div>


      <hr style="margin-top:0px; margin-bottom:0px; width:80%; border-top: 1px solid #000;">
      <hr style="margin-top:2px; margin-bottom:0px; width:80%; border-top: 3px solid #000;">
      <div class="modal-footer">
        <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
      </div>
    </div>
  </div>
</div>
  
  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
  
    <a id="menu-switch"><i class="fa fa-bars fa-lg"></i></a>
  
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>