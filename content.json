{"meta":{"title":"NCJ-Blog","subtitle":"NCJ's Blog - A Geek's Homepage","description":"A Geek's Homepage","author":"NCJ","url":"https://ncj.wiki","root":"/"},"pages":[{"title":"About Me","date":"2019-02-19T13:51:09.000Z","updated":"2019-09-05T13:38:45.735Z","comments":true,"path":"about/index.html","permalink":"https://ncj.wiki/about/index.html","excerpt":"","text":"Hi, this is NCJ! And welcome to my blog! I love Tech, including everything that’s new. I love my major, and it’s just one of the reasons why I start this blog, I want to share some of my thoughts about major, like some skillful algorithms. I also love photography. However, I hate my works being covered up by others’ QQ zones posts, so I’ll post them on this site from now on. Ways to Contact Me &emsp;E-mail: iamncj@outlook.com &emsp;GitHub: https://github.com/iamNCJ 友链： A roommate in software academy nessoffice.github.io"},{"title":"categories","date":"2019-09-05T13:38:45.735Z","updated":"2019-09-05T13:38:45.735Z","comments":true,"path":"categories/index.html","permalink":"https://ncj.wiki/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-09-05T13:38:45.736Z","updated":"2019-09-05T13:38:45.736Z","comments":true,"path":"tags/index.html","permalink":"https://ncj.wiki/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"小米Mix 2s多系统安装教程","slug":"2020-01-26_MultiROM_Mix2s","date":"2020-01-26T02:00:00.000Z","updated":"2020-01-26T11:34:03.936Z","comments":true,"path":"2020/01/26/2020-01-26_MultiROM_Mix2s/","link":"","permalink":"https://ncj.wiki/2020/01/26/2020-01-26_MultiROM_Mix2s/","excerpt":"","text":"折腾了两天，总算成功实现了安卓手机的多系统，在此记录一下，权且做一个教程，给其他热爱折腾的人做一点参考。 首先要说明的是安装双系统乃至多系统，尤其是在手机上，对于很多人来说绝对是非常鸡肋的，而且安装的过程肯定会造成原先数据的丢失等等，安装之后也不能保证所有功能的正常（比如视频），但是对于爱玩机的人来说，能够经常体验不同的ROM还是很重要的。我之所以想安装多系统，就是因为发现了两个都让我非常喜欢的ROM——Pixel Experience 和 Simplicity。这两个ROM可谓是两个极端，一个是纯原生安卓的体验，手感非常的好，吊打国内的各大ROM（这才是安卓啊），另一个则是浓厚的极客气息（自带Magisk、Busybox，以及各种底层破解……），在分别体验了两个ROM之后，我发现对它们都是爱不释手。小孩子才做选择，成年人全都要，多启动的想法自然而然地萌生了出来。 我的设备是Xiaomi Mix 2s (polaris) 国行6+64GB，其他设备的用户本教程可能并不适用，仅供参考 免责声明：本人不对任何教程中的操作造成的数据丢失以及设备损坏负责，请在操作前做好数据备份 一、常见方案折腾前当然要看看有啥现成的轮子了，大致研究了一下界内的方案，基本都在XDA的这篇文章里讲到了，这里简单概括一下。 MultiROM 官方Wiki 作用于bootloader之后，可以用于引导不同的系统（含Linux），XDA称这是“已知的最好的多系统解决方案”。 https://forum.xda-developers.com/xiaomi-mi-mix-2s/how-to/multirom-multirom-polaris-t3957428 DualBoot Patcher 官网 非常有名的安卓引导工具，XDA高级成员，陈小龙大牛开发&amp;&amp;维护，但是在安卓10到来之后，开发者停止维护了。主要是由于新版安卓在架构上的一些调整造成了开发的困难。但是我想要安装Pixel Experience正是基于安卓10的，所以这个方案不行。 GRUB for Android GRUB是x86架构上知名的引导程序，那么GRUB4Android顾名思义也是一个原生bootloader的替代品。现在这个项目已经衍生为了EFIDroid，但是看了一下官网最后一次更新是2016年，现在貌似也没有对Mix 2s进行适配，所以就放弃了。 综合以上，我最后选择MultiROM作为多系统的解决方案。 二、安装MultiROM版TWRP在安装ROM之前，我们首先需要对引导程序进行一些处理。 1. 解锁BootLoaderBootLoader是嵌入式设备在操作系统内核运行之前运行的一段程序，它相当于控制了整个启动的大方向，厂商往往会在BootLoader里加入一些检查代码，限制非官方的系统的启动。因此如果想要进行刷机、root等操作，必须将厂商的限制解除。 由于BootLoader与硬件强绑定，因此必须通过厂商的官方途径（或者万能的淘宝）进行解锁。小米官方提供了解锁方式，傻瓜操作，在此略过。 2. 刷入Recovery安卓刷机一般使用TWRP，这是一个开源的第三方Recovery，可以用于替换官方的Recovery，从而更方便地进行刷机等操作。 刷入的过程非常简单，重启手机进入fastboot模式之后，连接手机与电脑，使用ADB进行以下操作： fastboot devices# 检查设备连接状态fastboot flash recovery your-TWRP.img# 将TWRP烧入Recovery 现在，TWRP已经在你的手机的Recovery分区下了。 3. 安装MultiROM补丁但是原版的TWRP并不支持多系统，因此我们需要安装TWRP之后打补丁，并替换MultiROM专用的TWRP版本。 而且因为嵌入式的强硬件相关性，我们需要根据自己的设备选择专用的MultiROM补丁，很幸运的是Mix 2s已经有人进行了适配，所以我们直接用轮子就好了。 我们打开相关页面，下载multirom_14-08-19.zip和recovery_3.3.1_17-08-19.img两个文件，储存在手机根目录或者U盘里，然后重启手机进入Recovery模式。 使用TWRP先刷入MultiROM补丁到原始ROM（操作与刷入Magisk类似，使用Install ZIP），再将recovery分区替换为MultiROM专用TWRP（使用Install Image）。 完成后再次重启手机，即可看到MultiROM已经安装完毕，此时理论上就可以使用MultiROM安装第二个ROM了。 三、安装第二个ROM此时进入Recovery分区，也能通过点击右上角的菜单进入MultiROM的配置菜单 点击Add ROM，ROM类型选择Android，安装地点选择内置储存Internal Storage 选择你想要安装的ROM即可。 教程结束。显然不会这么简单，如果你安装的两个ROM都是安卓9及以下，而且是比较轻量化的ROM或者官方系统，那么以上应该就够了。但是如果你是安装安卓10或者含有root或者大量魔改的ROM，那么你的工作，才刚刚开始…… 四、安装Pixel Experience根据XDA论坛上提供MultiROM的大神的介绍，安卓10需要作为主ROM进行安装，具体可能与安卓10的加密机制有关。（具体原因尚不清楚，但是在安装完基于安卓10的系统后，文件系统是被加密的，需要安装MultiROM的补丁才能禁用掉加密）。 后来测试发现安卓10测试版也是可以直接刷入的……，可能只是Pixel Experience必须作为主ROM安装，或者安卓10正式版不能作为次ROM安装。 总之安卓10（在我这儿我选择的是Pixel Experience）必须在一开始就安装，然后在重启手机完成初始化之后再打补丁（不然可能会再初始化时卡住）。 在检查安卓10可以正常启动，MultiROM工作正常后，我们就可以继续安装其他的ROM了。 五、魔改并安装其他ROM1. MIUI10MIUI是基于安卓9的（虽然小米修改安卓版本号为10.0.0，但是实际上还是9的底层）。 使用MIUI10开发版（版本号9.8.22），可以正常作为Secondary ROM安装，没有遇到大问题。 2. Simplicity首先尝试安装最新版的基于安卓10的Simpilicty，直接安装会触发E1001: Failed to update system image.的报错。 然后尝试安装基于安卓9的旧版Simplicity，发现仍然会触发这个报错。考虑到Simplicity本质上就是对MIUI的破解，开始对旧版Simplicity的ROM进行魔改。 因为安卓的ROM安装过程是由updater-script脚本控制的，它位于your-ROM.zip\\META-INF\\com\\google\\android目录下。打开后发现官方能够直接作为第二系统刷入的ROM是按照boot、system、vendor、firmware的顺序进行patch的，而Simplicity是按照boot、firmware、system、vendor的顺序进行patch的，于是修改updater-script，将patch顺序进行调换。 ## BEFOREui_print(\"Patching boot image unconditionally...\");package_extract_file(\"boot.img\", \"/dev/block/bootdevice/by-name/boot\");ui_print(\"Patching firmware images...\");package_extract_file(\"firmware-update/dsp.img\", \"/dev/block/bootdevice/by-name/dsp\");... # details omittedpackage_extract_file(\"firmware-update/hyp.img\", \"/dev/block/bootdevice/by-name/hyp_b\");show_progress(0.600000, 250);ui_print(\"Patching system image unconditionally...\");block_image_update(\"/dev/block/bootdevice/by-name/system\", package_extract_file(\"system.transfer.list\"), \"system.new.dat\", \"system.patch.dat\") || abort(\"E1001: Failed to update system image.\");ui_print(\"Patching vendor image unconditionally...\");block_image_update(\"/dev/block/bootdevice/by-name/vendor\", package_extract_file(\"vendor.transfer.list\"), \"vendor.new.dat\", \"vendor.patch.dat\") || abort(\"E2001: Failed to update vendor image.\");ui_print(\" \");## AFTER# Patch boot firstui_print(\"Patching boot image unconditionally...\");package_extract_file(\"boot.img\", \"/dev/block/bootdevice/by-name/boot\");# Patch system and vendor before firmwareui_print(\"Patching system image unconditionally...\");block_image_update(\"/dev/block/bootdevice/by-name/system\", package_extract_file(\"system.transfer.list\"), \"system.new.dat\", \"system.patch.dat\") || abort(\"E1001: Failed to update system image.\");ui_print(\"Patching vendor image unconditionally...\");block_image_update(\"/dev/block/bootdevice/by-name/vendor\", package_extract_file(\"vendor.transfer.list\"), \"vendor.new.dat\", \"vendor.patch.dat\") || abort(\"E2001: Failed to update vendor image.\");ui_print(\" \");# Patch firmware at lastui_print(\"Patching firmware images...\");package_extract_file(\"firmware-update/dsp.img\", \"/dev/block/bootdevice/by-name/dsp\");... # details omittedpackage_extract_file(\"firmware-update/hyp.img\", \"/dev/block/bootdevice/by-name/hyp_b\");show_progress(0.600000, 250); 修改之后，即可正常安装，重启后能够进入系统，root等功能正常，安装成功。 六、体验与缺陷整体来讲，双系统的切换还算流畅，切换的成本不是很高。 作为主系统的Pixel Experience手感非常好，功能基本正常，但是每次启动的时候都要重新设置时间，双摄不能正常使用（未适配）。 作为次系统的Simplicity有各种极客功能，主题也被破解了，可以免费换自己喜欢的使用，内置的迅雷下载加速也被破解为付费模式，可以把家里带宽跑满。但是估计是由于MulitROM启动次系统的时候只切换部分挂载的原因，GPU或者DSP驱动似乎有些问题，导致视频解码有问题，视频无法正常播放（作为次系统的MIUI也有这个问题）。 整体来说，还是实现了一开始的目的，反正小米也不是日用主力机，Pixel主要是用手感和Google的全家桶（手动狗头），Simplicity主要就是为了下载奇怪的资源和一些ROOT功能（比如虚拟定位，再次狗头）。 当然折腾的过程也大致了解了一些安卓底层的东西，但是所知还是甚少，看来还是要多读书，多学习（狗头.jpg 踩坑完毕","categories":[],"tags":[{"name":"Geek","slug":"Geek","permalink":"https://ncj.wiki/tags/Geek/"},{"name":"Android","slug":"Android","permalink":"https://ncj.wiki/tags/Android/"},{"name":"ROM","slug":"ROM","permalink":"https://ncj.wiki/tags/ROM/"},{"name":"Boot","slug":"Boot","permalink":"https://ncj.wiki/tags/Boot/"},{"name":"ARM64","slug":"ARM64","permalink":"https://ncj.wiki/tags/ARM64/"}]},{"title":"校网环境下的私人服务器解决方案","slug":"2019-07-10_Dorm_Server","date":"2019-07-10T02:05:16.000Z","updated":"2019-09-05T13:38:45.732Z","comments":true,"path":"2019/07/10/2019-07-10_Dorm_Server/","link":"","permalink":"https://ncj.wiki/2019/07/10/2019-07-10_Dorm_Server/","excerpt":"","text":"CS狗一枚，几乎每天都需要携带电脑。最近感觉轻薄本性能不太够用，但是游戏本又太厚太重、散热续航也不太行，于是想到在寝室部署一台台式机，然后远程访问计算资源的方案。考虑到校网拓扑的复杂以及供电等原因，最近先进行了一些理论验证，并成功组建了一个个人网络以及一些个人网络服务。以下是过程的简单记录。 一、路由器的必要性与选购在ZJU，寝室要想访问外网，只有两个方案——学校的WiFi或者有线网VPN拨号。考虑到ZJUWLAN严重的丢包问题，以及时不时被踢下需要重新验证的问题，我毫不犹豫地选择了有线网。 但是由于学校的另一条规定——每个VPN账号只能在一台电脑上登录，而我手上的需要联网的设备远不止两台，因此路由器的出现就很有必要了。 使用路由器的另一个好处是如果VPN掉线会自动重新拨号，在之后的服务搭建中，虚拟服务器功能也起到了极大的作用。因此路由器是非常必要的。 至于选购的话，其实只要支持L2TP即可，不过最近很多家用路由器都取消了这个功能，所以采购的时候还是留点心为好，至少不要以为所有路由器都支持这玩意。 二、网络拓扑的设计以及IP地址的获取1. 有线连接与无线连接的选择寝室需要一直联网的设备： Windows电脑一台 树莓派3b+ 这两个设备均采用有线连接，特别是Windows电脑，因为RDP需要传输图像，并且出于鲁棒性考虑同时也连接了无线网，以免出现有线网卡莫名出故障导致无法访问的意外 树莓派连有线是因为需要高带宽，毕竟作为下载机（校内P2P下载） 当我回到寝室时，可能iPhone和小米都要联网，以及我的kindle和Ubuntu笔记本 这些设备直接使用无线网连接好了，毕竟连接外网的带宽也就12Mbps，有线网带宽可谓是绰绰有余 2. 不使用DMZ的原因 不安全，直接把某一台电脑的所有端口直接暴露在外网中是一件极其危险的事情 DMZ只能转发请求到一台设备，但是我的Windows和Pi都需要跑服务，各自有不同的端口需要转发，这是DMZ不支持的 因此，我选择使用虚拟服务器进行配置 3. 虚拟服务器实现端口转发目前需要的服务： 服务 端口号 Windows上的RDP 3389 Windows上WSL中的Jupyter Lab 8080 Windows上WSL的SSH 22 Pi上的FTP 21 Pi上的BT下载监控 9091 Pi上的Web服务 8080 Pi上的SSH 22 将相应端口进行分别转发即可 对于Windows上Lab和Pi上Web等端口相同的问题，直接在外网设置不同的端口，再分别转发即可，甚至出于安全考虑，更加推荐避免内外端口一致，以防闲的没事的人（暗指某室友）突然访问你的各种服务……（当然他要是知道了我的IP还是可以一个端口一个端口逐个扫描……） 好在他并不知道我的IP，甚至如果我在外面的话，自己都不太方便知道自己的IP…… 这就引出了下面的重磅话题—— 4. 查看IP地址的方法不要问我为什么不申请固定IP……（手慢无 被申请完了……) 另外申请的固定IP其实是比公网IP低一级的，而对于我这种直接通过VPN拨号访问外网的用户，即使申请到了固定IP也是没法用到L2TP拨号中的，因为我是直接连到学校总对外网关上的，跳过了宿舍网关这一层（这也导致直接通过宿舍有线网是无法ping通我的） 同时，每次路由器掉线重拨后，IP地址都会变。这就令人十分窒息，因为有时候就算早上出门前瞅一眼路由器的IP，中午的时候它可能就又变了…… 于是就有了以下几种可能的方案： 1. 在大致的网段范围内逐个扫描效率多低、多慢就不用说吧…… 2. 定时推送最新IP推送的方式有无数种，如QQ、微信、邮件等，此处不赘述 对于推送的时间，之前设想的是每天早上上电之后推送，但是现在发现IP居然可以一日多变…… 半小时一推的话，如果IP变化恰好处在了06:30:19之类的时间，那就干等半小时吧 5min一推怕是跟骚扰信息一样…… 比较好的方案应该是5min获取一次IP，然后跟上次的比对，如果不同再推送 但是 如何获取IP呢？ 不要以为这个问题很简单，如果你试着ifconfig的话，会发现得到的是自己小网络里面的ip…… 如果用网上给出的方法，用爬虫爬一些IP查询网站，会发现给你的是公网IP，而不是学校网关分配给你的那个…… 哦豁！ 我目前的想法是，直接爬虫登录路由器管理页面，然后找出里面的IP信息…… 如果有更好的方案，请让我知道，谢谢 3. 内网穿透域名我是有的，构建的流程也基本上清楚，但是如果内网的IP总是在变的话，也没法穿透…… 3. 直接使用路由器厂商的外网管理服务最简单粗暴，但是最有效 于是我就选了这个最没有技术含量的方案……（太菜了没办法……） 能找到寝室路由器（或者叫网关更贴切）后，就可以开始下面的各项工作了 三、远程桌面服务的配置Win10专业版可以直接开启RDP Win10家庭版可以通过GItHub上的开源工具(https://github.com/stascorp/rdpwrap )开启RDP，但是不太稳定（每次连接前需要使用工具手动开启一下） server机的缩放最好设为100%，不然client机连接之后可能会出现菜单显示很奇怪的问题 四、Jupyter Lab的配置跑在Windows主机下的WSL中，因为Windows下开发环境实在是太难配置了 当然，如果之后的使用中发现WSL有明显的性能损失的话，不排除还是会回归纯Linux 四、基于树莓派的下载机1. Aria2主要用于普通链接的下载 2. Transmission BT下载机主要用于HND上面的校内BT资源下载 目前这套方案运作良好，如果之后有改进会在后续文章中介绍","categories":[],"tags":[{"name":"Network","slug":"Network","permalink":"https://ncj.wiki/tags/Network/"},{"name":"Geek","slug":"Geek","permalink":"https://ncj.wiki/tags/Geek/"},{"name":"Server","slug":"Server","permalink":"https://ncj.wiki/tags/Server/"}]},{"title":"四月随想","slug":"2019-04-08_April-thoughts","date":"2019-04-08T03:33:24.000Z","updated":"2019-09-05T13:38:45.732Z","comments":true,"path":"2019/04/08/2019-04-08_April-thoughts/","link":"","permalink":"https://ncj.wiki/2019/04/08/2019-04-08_April-thoughts/","excerpt":"","text":"function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } U2FsdGVkX19q8PDiRFJ0wDhCv/jctSnps9fDA3xfrheLaLLyavZWyoJ1qEN0LnmC5U9tHsbjVJ2IkZSi2vumAQD98FGB90aeZBwEojaGZEg0wDt3Zsd3n+RINoFwNPiTqdH3fZJ2Q12vej++I3tArvTyYqd7VrWAP9O7//gc3GOAHEZEPLkloP5lL+1Ci8lQI5OOKJWD2OccHwO5R7H5iXN5D9y14qIhENQYiP4rsasVXhcDhHddl04ClH4bn32a3toPKStJvaoS6M7wx9nuETL31ebMn4Ry8lEIM3rb1oEI4vVqZzL0DK1QSsfhEn5V2kLOxQO9JdnrMx7FL3dGPhIGr4QV12maeEc+0ycmqM/101IetkzUpWsmoqi9CMV+OemME0fVtUfAQ+Bp0zNtl2xgQDCplkmlVA0ol+GqkqEtl2IIQATVojwqrMNbhjErDLRMeJ14UmKn97+P70ZSv14Gl0mRcHm7igTMXXrvdxLTZ8jTkdI4/DL9bMLSkRMOJcdJ40BlGCSjI3V+8X29fI7E+bZ5gkifQdRdKoU7L5OQojaKr8QVAZKB0cD2AtQSI6TUDp6eFbhTsn+JsST9nn7bwEkqZ0hiJF5SRoOmIQ3pSYsOmxHJ77mWaPEpm+32HYPDfC8Kv859eGxc55WOT1vnW3L5Q6KRNiRDFyRGd4bxcbkqgZ/YLMeDDUsv9tsRhHN4+2C63Ouspv6miK2/0IijjWWkkbILzK4ma/hLU+c= var onError = function(error) { document.getElementById(\"enc_error\").innerHTML = \"password error!\" }; function decrypt() { var passwd = document.getElementById(\"enc_pwd_input\").value; console.log(passwd); doDecrypt(passwd, onError); }","categories":[],"tags":[{"name":"Thoughts","slug":"Thoughts","permalink":"https://ncj.wiki/tags/Thoughts/"}]},{"title":"【DM】离散数学笔记GitBook页面已上线","slug":"2019-04-04_DM_Notes_Post","date":"2019-04-04T00:34:52.000Z","updated":"2019-09-05T13:38:45.732Z","comments":true,"path":"2019/04/04/2019-04-04_DM_Notes_Post/","link":"","permalink":"https://ncj.wiki/2019/04/04/2019-04-04_DM_Notes_Post/","excerpt":"","text":"离散数学的笔记今后将在该项目的GitHub Pages上发布，不再同步至本网站。新的页面采用GitBook渲染制作，更适合于笔记的阅读，欢迎大家围观。 离散数学笔记网站： https://iamncj.github.io/Discrete_Mathematics_Explained_in_Detail 项目本身： https://github.com/iamNCJ/Discrete_Mathematics_Explained_in_Detail","categories":[],"tags":[{"name":"Discrete Math","slug":"Discrete-Math","permalink":"https://ncj.wiki/tags/Discrete-Math/"}]},{"title":"记一次奇葩的爬虫踩坑经历","slug":"2019-04-04_Crawl_Notes","date":"2019-04-03T23:56:58.000Z","updated":"2019-09-05T13:38:45.732Z","comments":true,"path":"2019/04/04/2019-04-04_Crawl_Notes/","link":"","permalink":"https://ncj.wiki/2019/04/04/2019-04-04_Crawl_Notes/","excerpt":"","text":"function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById(\"enc_error\").innerHTML = \"password error!\" }; function decrypt() { var passwd = document.getElementById(\"enc_pwd_input\").value; console.log(passwd); doDecrypt(passwd, onError); }","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://ncj.wiki/tags/Python/"},{"name":"Crawl","slug":"Crawl","permalink":"https://ncj.wiki/tags/Crawl/"},{"name":"Python Request","slug":"Python-Request","permalink":"https://ncj.wiki/tags/Python-Request/"}]},{"title":"在WSL上安装GNOME桌面方法的正解","slug":"2019-04-03_Gnome","date":"2019-04-03T12:55:00.000Z","updated":"2019-09-05T13:38:45.731Z","comments":true,"path":"2019/04/03/2019-04-03_Gnome/","link":"","permalink":"https://ncj.wiki/2019/04/03/2019-04-03_Gnome/","excerpt":"","text":"网上的教程千篇一律安装的是Unity桌面，而Unity真心难用！自己折腾了一下成功了，简单记录一下方法，帮大家踩踩坑 Step1. 通过tasksel安装Ubuntu Desktop通过任务的方式安装Ubuntu Desktop tasksel有一个基于curses的GUI 用空格选择Ubuntu Desktop，回车安装即可 这样装下来的Ubuntu Desktop是Gnome版的，CSDN上流传的那些指令装下来的全是Unity环境 tasksel安装的好处是无需过多关心包依赖等问题，缺陷在于会安装很多我们不想要的包，比如libreoffice，但是这些多余的包可以日后卸载 Step2. 安装并启动Xming 启动完整桌面环境时用这个（其余的参数都不用改！包括Display number！） 如果你只是想用用单个程序的GUI界面，选Multiple windows就好了 Step3. 启动GNOME桌面注意四点： Gnome目前还不稳定，因此启动前最好确保dbus服务正在运行，最简单的方式就是start或者restart一下 需要指定桌面端口以及会话类型（X11） 要加sudo，因为Gnome启动时，dconf也会启动，而后者要在用户根目录下的.cache内创建一个文件夹dconf，估计是想存放一些配置参数之类的，不用sudo的话会在这一步进入死循环，如图 因为已经是超级用户了，所以进入gnome环境后你的身份就是root，不用多说了吧，干啥都悠着点好了…… 上命令： sudo service dbus startsudo DISPLAY=:0 XDG_SESSION_TYPE=x11 gnome-session 好了，现在该怎么折腾就怎么折腾吧……（比如把libreoffice等用Ubuntu Software卸载掉） Step4. 简化日后操作为了日后简单起见，其实可以通过向.bashrc中写入export DISPLAY=:0.0的方式，让每次启动bash时都运行这句话。毕竟开gnome完整桌面环境的频率还是没有开单个GUI程序的频率高，因此加上这一步可以简化日后在Xming中启动单个GUI程序的指令 echo \"export DISPLAY=:0.0\" &gt;&gt; ~/.bashrc 此后我们再想启动gnome桌面时，直接输入以下命令就好 sudo service dbus restartsudo XDG_SESSION_TYPE=x11 gnome-session 而单个程序就更简单了，比如 gedit 展现一下“混合系统”的效果…… 踩坑完毕","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://ncj.wiki/tags/Linux/"},{"name":"WSL","slug":"WSL","permalink":"https://ncj.wiki/tags/WSL/"},{"name":"Gnome","slug":"Gnome","permalink":"https://ncj.wiki/tags/Gnome/"}]},{"title":"【DM】CH02-01 Set","slug":"DM/CH02_Basic_Structures/CH02_01_Set","date":"2019-03-18T02:45:29.000Z","updated":"2019-09-05T13:38:45.735Z","comments":true,"path":"2019/03/18/DM/CH02_Basic_Structures/CH02_01_Set/","link":"","permalink":"https://ncj.wiki/2019/03/18/DM/CH02_Basic_Structures/CH02_01_Set/","excerpt":"","text":"Chaptcer 02 Basic Structures 基本结构 Part 01 Set Covering2.1 ~ 2.2 Set 集合Basic 基本属性Definition 定义A set is an unordered collection of objects. 集合是对象的一个无序聚集。 Note: The Order of elements does not matter {1, 2, 3} = {3, 2, 1} Repetition of elements does not matter {1, 1, 2, 3, 3} = {1, 2, 3} The objects in a set are called the elements（元素）, or members（成员）, of the set. A set is said to contain（包含） its elements. Note: Uppercase letters are usually used to denote sets, and lowercase letters are usually used to denote elements of sets. a ∈ A: a is a member (an element) of the set A a ∉ A: a is not an element of the set A Description 描述方法Roster Method 花名册法listing all its members between braces e.g. S = {a, b, c, d} Brace Notation with Ellipses 省略号记法Sometimes the roster method is used to describe a set without listing all its members. Some members of the set are listed, and then ellipses (. . .) are used when the general pattern of the elements is obvious. e.g. The set S of positive integers less than 100 can be denoted by S = {1, 2, 3, . . . , 99 } Set Builder 构造器We characterize all those elements in the set by stating the property or properties they must have to be members. e.g. {x | x is an odd positive integer less than 10} Truth Sets 真值集Given a predicate P, and a domain D, we define the truth set of P to be the set of elements x in D for which P(x) is true. The truth set of P(x) is denoted by {x ∈ D | P(x)}. Venn Diagrams 文氏图 In Venn diagrams, the universal set U is represented by a rectangle. Inside this rectangle, circles or other geometrical figures are used to represent sets. Points are used to represent the particular elements of the set. Property 性质The Relations Between Two Sets 集合间的关系Subset 子集$A ⊆ B ⇔ ∀x(x ∈ A → x ∈ B)​$ For any set A $\\phi ⊆A$ $A⊆A​$ Equal 相等$A=B\\\\⇔∀x[(x∈A→x∈B)∧(x∈B→x∈A)]\\\\⇔(A⊆B)∧(B⊆A)$ To show that two sets A and B are equal, show that A ⊆ B and B ⊆ A. Proper subset 真子集$A⊂B\\\\⇔∀x(x∈A→x∈B)∧∃x(x∈B∧x∉A)\\\\⇔(A⊆B)∧(A≠B)$ The Size of a Set 集合的大小Let S be a set. If there are exactly n distinct elements in S where n is a nonnegative integer, we say that S is a finite（有限的） set and that n is the cardinality（基数） of S. Notation: |S| -&gt; the cardinality of S e.g. Let A be the set of odd positive integers less than 10. Then |A| = 5. ​ |∅| = 0 A set is said to be infinite（无限的） if it is not finite e.g. The set of positive integers is infinite Power Set 幂集Given a set S, the power set of S is the set of all subsets of the set S. Notation: P(S) -&gt; the power set of S Note: |S|=n implies |P(S)| = $2^n​$ S is finite and so is P(S) $x∈P(S)⇒x⊆S（此处x是一个集合）\\\\x∈S⇒{x}∈P(S)（此处x是一个元素）\\\\S∈P(S)$ e.g. What is the power set of the empty set? What is the power set of the set {∅}? The empty set has exactly one subset, namely, itself. Consequently,P(∅) = {∅}.The set {∅} has exactly two subsets, namely, ∅ and the set {∅} itself. Therefore,P({∅}) = {∅, {∅}}. A good way to check is to make sure |P(S)| = $2^n$ Cartesian Products 笛卡尔积Tuple 元组The ordered n-tuple（有序n元组） (a1, a2, . . . , an) is the ordered collection that has a1 as its first element, a2 as its second element, . . . , and an as its n-th element. In particular, ordered 2-tuples are called ordered pairs（序偶） $(x,y)=(u,v)⇒(x=u)∧(y=u)$ If $x≠y$, then $(x,y)≠(y,x)$ The Cartesian product of A and B, denoted by A × B, is the set of all ordered pairs (a, b), where a ∈ A and b ∈ B. $A × B = {(a, b) | a ∈ A ∧ b ∈ B}$ $A_1 × A_2 ×· · ·×A_n = {(a_1, a_2, . . . , a_n) | a_i ∈ A_i\\ for\\ i = 1, 2, . . . , n}$ Note: If |A|=m, |B|=n, then |A×B|=|B×A|=mn A×B≠B×A A×∅ = ∅×A = ∅ Set Operations 集合运算Intersection 交集$A∩B={x|x∈A∧x∈B}​$ Two sets are called disjoint if their intersection is the empty set, namely $A∩B = Ø$ Generalized Intersections 拓展的交集$A1∩A_2∩…∩A_n=\\bigcap{i=1}^{n}A_i$ Union 并集$A∪B={x|x∈A∨x∈B}​$ The cardinality of the union of two finite sets: $|A∪B|=|A|+|B|-|A∩B|$ Generalized Unions 拓展的并集$A1∪A_2∪…∪A_n=\\bigcup{i=1}^{n}A_i$ Difference 差集$A-B={x|x∈A∧x∉B}​$ Complement 补集$\\overline{A} = {x ∈ U | x ∉ A}​$ (U is the universal set) Note: $A-B=A∩\\overline{B}​$ Symmetric Difference 对称差分$A⊕B=(A∪B)-(A∩B)​$ Set Identities 集合恒等式 Identity 恒等式 Name 名称 $A ∩ U = A\\\\A ∪ ∅ = A$ Identity laws 恒等率 $A ∪ U = U\\\\A∩∅ = ∅$ Domination laws 支配率 $A ∪ A = A\\\\A ∩ A = A$ Idempotent laws 幂等律 $\\overline{\\overline{A}}=A$ Complementation law 补率 $A ∪ B = B ∪ A\\\\A ∩ B = B ∩ A$ Commutative laws 交换律 $A ∪ (B ∪ C) = (A ∪ B) ∪ C\\\\A ∩ (B ∩ C) = (A ∩ B) ∩ C$ Associative laws 结合律 $A ∪ (B ∩ C) = (A ∪ B) ∩ (A ∪ C)\\\\A ∩ (B ∪ C) = (A ∩ B) ∪ (A ∩ C)$ Distributive laws 分配律 $\\overline{A ∩ B} = \\overline{A} ∪ \\overline{B}\\\\\\overline{A ∪ B} = \\overline{A} ∩ \\overline{B}$ De Morgan’s laws 德·摩根率 $A ∪ (A ∩ B) = A\\\\A ∩ (A ∪ B) = A$ Absorption laws 吸收率 $A ∪ \\overline{A} = U\\\\A ∩ \\overline{A} = ∅$ Complement laws 互补率 Ways to Prove Set Identities 集合恒等式的证明方法I. Show that A ⊆ B and that B ⊆ A New and important II. Use logical equivalences to prove equivalent set definitions Easy but tedious III. Use a membership table Like truth tables IV. Use previously proven identities Like ≡ Computer Representation of Set 集合的计算机表示Using bit strings to represent sets Specify an arbitrary ordering of the elements of U, for instance $a_1,a_2,…,a_n$ Represent a subset A of U with the bit string of length n, where the i-th bit is 1 if $a_i$ belongs to A and is 0 if $a_i$ does not belong to A. Thus, Union -&gt; bitwise OR Intersection -&gt; bitwise AND Example: Let U ={1, 2, 3, 4, 5,6,7,8,9}, A={1, 2, 3, 4, 5}, B= (1, 3, 5, 7, 9). The bit string for the set A: 11 1110 000 The bit string for the set B: 10 1010 101","categories":[],"tags":[{"name":"Discrete Math","slug":"Discrete-Math","permalink":"https://ncj.wiki/tags/Discrete-Math/"}]},{"title":"【DM】CH01-04 Rules of Inference and Proofs","slug":"DM/CH01_Logic_and_Proofs/CH01_04_Rules_of_Inference_and_Proofs","date":"2019-03-13T12:45:29.000Z","updated":"2019-09-05T13:38:45.734Z","comments":true,"path":"2019/03/13/DM/CH01_Logic_and_Proofs/CH01_04_Rules_of_Inference_and_Proofs/","link":"","permalink":"https://ncj.wiki/2019/03/13/DM/CH01_Logic_and_Proofs/CH01_04_Rules_of_Inference_and_Proofs/","excerpt":"","text":"Chapter 01 Logic and Proofs 逻辑与证明 Part 04 Rules of Inference and Proofs Covering 1.6~1.8 Rules of Inference 推理规则 Proofs in mathematics are valid arguments An argument（论证） is a sequence of statements that end with a conclusion By valid（有效性）, we mean the conclusion must follow from the truth of the preceding statements (premises（前提）) Valid Arguments in Propositional Logic 命题逻辑的有效论证An argument in propositional logic is a sequence of propositions. All but the final proposition in the argument are called premises and the final proposition is called the conclusion. An argument is valid if the truth of all its premises implies that the conclusion is true. An argument form（论证形式） in propositional logic is a sequence of compound propositions involving propositional variables. An argument form is valid if no matter which particular propositions are substituted for the propositional variables in its premises, the conclusion is true if the premises are all true. $p_1\\\\p_2\\\\…\\\\p_n\\\\ - \\\\∴q​$ An argument in propositional logic is valid when its argument form is valid. e.g. Rules of Inference 推理原则Rules of Inference for Propositional Logic 命题逻辑的推理原则 Rule of Inference Tautology Name $p\\\\p → q\\\\ —- \\\\∴q$ $(p ∧ (p → q)) → q$ Modus ponens 假言推理 $¬q\\\\p → q\\\\—-\\\\∴ ¬p$ $(¬q ∧ (p → q))→¬p$ Modus tollens 取拒式 $p → q\\\\q → r\\\\—-\\\\∴ p → r$ $((p → q) ∧ (q → r)) → (p → r)$ Hypothetical syllogism 假言三段论 $p ∨ q\\\\¬p\\\\—-\\\\∴ q$ $((p ∨ q)∧¬p) → q$ Disjunctive syllogism 析取三段论 $p\\\\—-\\\\∴ p ∨ q$ $p → (p ∨ q)$ Addition 附加律 $p ∧ q\\\\—-\\\\∴ p$ $(p ∧ q) → p$ Simplification 化简律 $p\\\\q\\\\—-\\\\∴ p ∧ q$ $((p) ∧ (q)) → (p ∧ q)$ Conjunction 合取律 $p ∨ q\\\\¬p ∨ r\\\\—-\\\\∴ q ∨ r$ $((p ∨ q) ∧ (¬p ∨ r)) → (q ∨ r)$ Resolution 消解律（Pay Attention!This rule has been used widely in many programmes） A valid argument can lead to an incorrect conclusion if one of its premises is wrong/false! Resolution 消解律 Computer programs have been developed to automate the task of reasoning and proving theorems. Many of these programs make use of a rule of inference known as resolution. This rule of inference is based on the tautology $((p ∨ q) ∧ (¬p ∨ r)) → (q ∨ r)$ The final disjunction in the resolution rule, $q ∨ r$, is called the resolvent（消解式） Resolution is very important in AI! Rules of Inference for Quantified Statements 量化命题的推理规则 Rule of Inference Name $∀xP(x)\\\\—-\\\\∴ P(c)$ Universal instantiation 全称实例 $P(c) for\\ an\\ arbitrary\\ c\\\\—————\\\\∴ ∀xP(x)$ Universal generalization 全称引入 $∃xP(x)\\\\——————\\\\∴ P(c)\\ for\\ some\\ element\\ c$ Existential instantiation 存在实例 $P(c)\\ for\\ some\\ element\\ c\\\\—————-\\\\∴ ∃xP(x)$ Existential generalization 存在引入 Combining Rules of Inference for Propositions and Quantified Statements 命题和量化命题的组合使用Universal Modus Ponens 全称假言推理$∀x(P(x) → Q(x))\\\\P(a),\\ where\\ a\\ is\\ a\\ particular\\ element\\ in\\ the\\ domain\\\\————————————\\\\∴ Q(a)​$ Universal Modus Tollens 全称取拒式$∀x(P(x) → Q(x))\\\\¬Q(a),\\ where\\ a\\ is\\ a\\ particular\\ element\\ in\\ the\\ domain\\\\————————————\\\\∴ ¬P(a)$ Using Rules of Inference to Build Arguments 使用推理规则建立论证 To prove that an argument is valid Assume the premises are true Use the rules of inference and logical equivalences to determine that the conclusion is true e.g.1 Propositional Logic 命题逻辑 Note: the second example added an additional premise for the conclusion is always true when r is false, so all we need to proove if that it’s true when r is true! Note: If the conclusion is given in a form of $p → q$ , we can convert the argument $p_1∧p_2∧…∧p_n→(p→q)$ to $p_1∧p_2∧…∧p_n∧p→q$ , because they are logically equivalent e.g.2 Quantified Statements 量化命题 e.g.3 Combination 组合使用 Invalid!!! For c depends on a! Fallacies 谬误Several common fallacies arise in incorrect arguments. These fallacies resemble rules of inference,but are based on contingencies rather than tautologies. Fallacy of denying the hypothesis 否定假设的谬误 If you overslept, you’ll be late. You didn’t oversleep. Therefore: You aren’t late. WRONG!! $p→q\\\\¬p\\\\—-\\\\∴¬q$ Fallacy of affirming the conclusion 肯定结论的谬误 If you are in China, you’re in Asia. You are in Asia. Therefore: You are in China. WRONG!! $p→q\\\\q\\\\—-\\\\∴p$ Introduction to Proofs 证明导论 The construction of a valid proof is an art, honed after much practice. Some Terminology 一些专业术语A proof（证明） is a valid argument that establishes the truth of a mathematical statement A theorem（定理） (proposition（命题）/fact（事实）/result（结论）) is a statement that can be shown to be true Axioms（公理） (postulates（假设）) are statements we assume to be true A lemma（引理） is a less important theorem that is helpful in the proof of other results A corollary（推论） is a theorem that can be established directly from a theorem that has been proved A conjecture（猜想） is a statement that is being proposed to be a true statement A conjecture becomes a theorem once it has been proved to be true Understanding How Theorems Are Stated 理解定理是如何陈述的Implied Universal Quantifiers 隐含全称量词e.g. “if x&gt;y, where x and y are positive real numbers, then $x^2&gt;y^2$.” For all positive real numbers x and y, if x&gt;y, then $x^2&gt;y^2$. Implicit Implications 暗示关系e.g. “The square of an odd integer is odd.” “if an integer n is odd, then $n^2$ is odd.” “For all integer n, if n is odd, then $n^2$ is odd.” Methods of Proving Theorems 证明方法Formal Proofs 形式化证明 Can be extremely long May be hard to follow Informal Proofs 非形式化证明 Each step may involve multiple rules of inference; Steps may be skipped; The axioms being assumed and the rules of inference used are not explicitly stated. Mistakes in Proofs 证明中的错误Many mistakes result from the introduction of steps that do not logically follow from those that precede it. Many incorrect arguments are based on a fallacy called begging the question (circular reasoning（循环论证）) Proof Methods 证明方法Direct Proofs 直接证明A direct proof shows that a conditional statement p → q is true by showing that if p is true, then q must also be true Indirect Proofs 间接证明Proof by Contraposition 反证法$P→Q≡¬Q→¬P​$ Vacuous Proof 空证明If we know P is false then P → Q is vacuously true. F → T and F → F are both true. e.g. If Tom is both handsome and ugly then he feels unhappy. Trivial Proof 平凡证明If we know Q is true, then P → Q is trivially true F → T and T → T are both true. e.g. If it’s raining today then the empty set is a subset of every set. Proof by Contradiction 归谬证明法$¬p→(q∧¬q)$ 直接的说，就是先假设p为假，然后推出两个相矛盾的结论 它与反证法的差别就在于反证法是找到与假设相悖的结论，而归谬证明法是由假设推出两个相悖的结论，即矛盾的产生处不同 Example: Prove there is no largest prime number. Proof: Let p be the proposition “there is no largest prime number.” Assume that ¬p is true, namely, there is a largest prime number, denoted by s. Hence, the set of all primes lie between 2 and s. Form the product of these primes: r=2×3×5×7×11×…×sBut r + 1 is a prime or has a prime factor larger than s. This is a contradiction since we have shown that ¬p implies both q and ¬q where q is the statement that s is the largest prime number. Hence, ¬p is false, so that p, “there is no largest prime number,” is true. Q.E.D. Proof p → q by Contradiction 运用归谬证明法证明蕴含关系 assumes that both p and ¬q are true shows that $(p∧¬q)→F​$ Proofs of Equivalence by Contradiction 运用归谬证明法的等价证明法$p↔q≡(p→q)∧(q→p)​$ $[p_1↔p_2↔…p_n]≡[(p_1→p_2)∧(p_2→p_3)∧…∧(p_n→p_1)]$ Counterexamples 反例证明法When presented with a statement of the form ∀xP(x), which we believe to be false or which has resisted all proof attempts, we look for a counterexample. Proof by Cases 分情形证明法就是分类讨论 Notice: You have to —— Convince the reader that the cases are inclusive (i.e., they exhaust all possibilities) Establish all implications Example: Prove that if n is an integer not divisible by 2 or 3, then n2-1 is divisible by 24. Solution: n = 6k+1 n = 6k+5 Exhaustive Proof 穷举证明法An exhaustive proof is a special type of proof by cases where each case involves checking a single example Example: Show that there are no solutions in integers x and y of $x^2 + 3y^2=8$ x = -2,-1,0,1,2 y = -1,0,1By exhausting every possible situation, we can draw the conclusion that this pair of x and y does not exist. Existence Proof 存在性证明Constructive Existence Proof 构造性证明 Establish P(c) is true for some c in the domain Then ∀xP(x) is true by Existential Generalization (EG) Example: Show that there are n consecutive composite positive integers for every positive integer n Explanation: $∀n∃x((x+i)\\ is\\ composite\\ for\\ i\\ = 1,2,…,n)$ Proof: Let x = (n + 1)! + 1. Consider the integers x + 1, x + 2, … , x + n. Note that i + 1 divides $x + i = (n + 1)! + (i + 1)\\ for\\ i = 1, 2, … , n$ Hence, n consecutive composite positive integers have been given. Q.E.D. Nonconstructive Existence Proof 非构造性证明Assume no c exists which makes P(c) true and derive a contradiction Example: Prove that for all integers n, there exists a prime p so that p &gt; n Proof: Let n be an arbitrary integer, and consider n! + 1. If (n! + 1) is prime, we are done since (n! + 1) &gt; n. But what if (n! + 1) is composite? If (n! + 1) is composite then it has a prime factorization: p_1×p_2×…×p_k=(n!+1)Consider the smallest $p_1$, it is still larger than n Let p = $p_1$ , then p &gt; n, and we are done. Q.E.D. Note: WE STILL DON’T KNOW WHAT p IS!!! Uniqueness Proof 唯一性证明There are two parts of a uniqueness proof: Existence: We show that an element x with the desired property exists. Uniqueness : We show that if y¹x, then y does not have the desired property. Equivalently, we can also show that if x and y both have the desired property, then x=y. Example: Show that if a and b are real numbers and a ≠ 0, then there is a unique real number r such that $ar+b=0$ Proof: Existence: Note that the real number $r = -b/a​$ is a solution of $ar + b = 0​$ because $a(-b/a)+b=-b+b=0​$. Thus, a real number r exists for which $ar + b = 0​$. Uniqueness: suppose that s is a real number such that $as + b = 0$. Then $as + b = ar + b$, where $r = -b/a$. Subtracting b from both sides, we find that as = ar. Dividing both sides of this last equation by a, which is nonzero, we see that s = r. Q.E.D. Proof Strategies 证明策略Forward Reasoning 正向推理Using premises, together with axioms and known theorems to lead to the conclusion. Example: Given two distinct positive real numbers x and y, their arithmetic mean is $(x+y)/2$ and their geometric mean is $\\sqrt{xy}$, the arithmetic mean is always greater than the geometric mean. Note: if you start from $(x+y)^2≥0$, then it’s forward reasoning if you start from $(x+y)/2&gt;\\sqrt{xy}$, which is the conclusion, then it’s backward reasoning, the strategy which we will talk about right below here. Backward Reasoning 反向推理To reason backward to prove a statement q, we find a statement p that we can prove with the property that p → q. Example: Suppose that two people play a game taking turns removing, 1, 2, or 3 stones at a time from a pile that begins with 15 stones. The person who removes the last stone wins the game. Show that the first player can win the game no matter what the second player does. Proof: Step n : Player1 can win if the pile contains 1,2, or 3 stones. Step n-1: Player2 will have to leave such a pile if the pile that he/she is faced with has 4 stones. Step n-2: Player1 can leave 4 stones when there are 5,6, or 7 stones left at the beginning of his/her turn. Step n-3: Player2 must leave such a pile, if there are 8 stones. Step n-4: Player1 has to have a pile with 9,10, or 11 stones to ensure that there are 8 left. Step n-5: Player2 needs to be faced with 12 stones to be forced to leave 9,10, or 11. Step n-6: Player1 can leave 12 stones by removing 3 stones. Now reasoning forward, the first player can ensure a win by removing 3 stones and leaving 12.","categories":[],"tags":[{"name":"Discrete Math","slug":"Discrete-Math","permalink":"https://ncj.wiki/tags/Discrete-Math/"}]},{"title":"【DM】CH01-03 Normal Form","slug":"DM/CH01_Logic_and_Proofs/CH01_03_Normal_Form","date":"2019-03-10T12:45:29.000Z","updated":"2019-09-05T13:38:45.734Z","comments":true,"path":"2019/03/10/DM/CH01_Logic_and_Proofs/CH01_03_Normal_Form/","link":"","permalink":"https://ncj.wiki/2019/03/10/DM/CH01_Logic_and_Proofs/CH01_03_Normal_Form/","excerpt":"","text":"Chapter 01 Logic and Proofs 逻辑与证明 Part 03 Normal_Form Propositional Normal Forms 命题范式A literal is a variable or its negation. Conjunctions with literals as conjuncts are called conjunctive clauses (clauses). 命题变量及其否定统称为文字 仅有有限个文字所构成的析取（合取）式称作简单（合取）式 Disjunctions (conjunctions) with one or more literals as disjuncts (conjuncts) are called disjunctive (conjunctive) clauses. 析取（合取）子句 Disjunctive and conjunctive clauses are simply called clauses. Two Normal Forms 两类基本范式Disjunctive Normal Form 析取范式 DNFA formula is said to be in disjunctive normal form if it is written as a disjunction, in which all the terms are conjunctions of literals. 由有限个简单析取式的合取构成的命题公式称为析取范式 Conjunctive Normal Form 合取范式 CNFA compound proposition is in Conjunctive Normal Form (CNF) if it is a conjunction of disjunctions. 由有限个简单合取式的析取构成的命题公式称为析取范式 Identify Normal Forms 判定范式 p DNF &amp; CNF ¬p ∨ q DNF &amp; CNF ¬p ∧ q ∧ ¬r DNF &amp; CNF ¬p ∨ (q ∧ ¬r) DNF ¬p ∧ (q ∨ ¬r) ∧ (¬q ∨ r) CNF The trick lies in that in some cases, clauses can be seen as a whole, and as a DNF or CNF. How to Obtain Normal Form 产生范式的方法 Faced with → &amp; ↔ p → q ≡ ¬p ∨ q p ↔ q ≡ (p → q) ∧ (q → p) Faced with ¬ $¬(p_1 ∧ p_2 ∧ … ∧ p_n) ≡ ¬p_1 ∨ ¬p_2 ∨ … ∨ ¬p_n​$ ¬¬p ≡ p Use of the commutative laws, the distributive laws and the associative laws to obtain normal form Full Disjunctive(Conjunctive) Normal Form 主析取（合取）范式Minterm and Maxterm 极小项、极大项A minterm is a conjunctive of literals in which each variable is represented exactly once. A maxterm is a disjunctive of literals in which each variable is represented exactly once. 在含有n个命题变量的简单合取式（简单析取式）中，若每个命题变量和它的否定恰好出现一个且仅出现一次，而且命题变量或它的否定式按下标从小到大或按字典序排列，称这样的简单合取式（简单析取式）为极小项（极大项） Full Disjunctive(Conjunctive) Normal Form 主析取（合取）范式If a formula is expressed as a disjunction of minterms, it is said to be in full disjunctive normal form. If a formula is expressed as a conjunctive of maxterms, it is said to be in full conjunctive normal form. 所有简单合取式（简单析取式）都是极小项（极大项）的析取范式（合取范式）称为主析取范式（主合取范式） [Important!] the Association Between Normal Forms and Truth Table （重点！）范式与真值表的关系DNF &amp; Truth Table The reason why this works: Each minterm is true for exactly one assignment. If A and B are two distinct minterms, then A ∧ B ≡ F. A disjunction of minterms is true only if at least one of its constituents minterms is true. CNF &amp; Truth Table Prenex Normal Form 前束范式 Why we need it? simplifies the surface structure of the sentence useful to automated theorem proving $Q_1x_1Q_2x_2…Q_nx_nB$ $Q_i(i = 1,2,…,n)$ is ∀ or ∃ and the formula B is quantifier free Any expression can be converted into prenex normal form. How to obtain prenex normal form? Eliminate all occurrences of → and ↔ from the formula in question. Move all negations inward such that, in the end, negation only appear as part of literals. Standardize the variables apart(when necessary). The prenex normal form can now be obtained by moving all quantifiers to the front of the formula. e.g.","categories":[],"tags":[{"name":"Discrete Math","slug":"Discrete-Math","permalink":"https://ncj.wiki/tags/Discrete-Math/"}]},{"title":"【DM】CH01-02 Predicate Logic and Nested Quantifiers","slug":"DM/CH01_Logic_and_Proofs/CH01_02_Predicate_Logic_and_Nested_Quantifiers","date":"2019-03-10T12:00:29.000Z","updated":"2019-09-05T13:38:45.734Z","comments":true,"path":"2019/03/10/DM/CH01_Logic_and_Proofs/CH01_02_Predicate_Logic_and_Nested_Quantifiers/","link":"","permalink":"https://ncj.wiki/2019/03/10/DM/CH01_Logic_and_Proofs/CH01_02_Predicate_Logic_and_Nested_Quantifiers/","excerpt":"","text":"Chapter 01 Logic and Proofs 逻辑与证明 Part 02 Predicate Logic and Nested Quantifiers Covering1.4 ~ 1.5 Predicate Logic 谓词逻辑Predicate and Quantifiers 谓词和量词的概念Predicate 谓词A predicate (propositional function 命题函数) is a statement that contains variables. Once the values of the variables are specified, the function has a truth value. $P(x_1,x_2,…,x_n)$ n-place (n-ary) predicate n位谓词（n元谓词） Quantifiers 量词We need quantifiersto express the meaning of English words including all and some. Universal Quantifier 全称量词“For all” ∀ ∀x P(x) is read as “For all x, P(x)” or “For every x, P(x)” The universal quantification of P(x) create a proposition from a propositional function. Existential Quantifier 存在量词“There exists” ∃ ∃x P(x) is read as “For some x, P(x)”, or as “There is an xsuch that P(x)”, or “For at least one x, P(x).” Properties of Quantifiers 量词性质 Statement When true? When false? $∀x P(x)$ P(x) is true for every x. There is an x for which P(x) is false. $∃x P(x)$ There is an x for which P(x) is true. P(x) is false for every x. Thinking about Quantifiers 深入理解量词Loop 循环When the domain of discourse is finite, we can think of quantification as looping through the elements of the domain. To evaluate ∀x P(x) loop through all x in the domain If at every step P(x) is true, then ∀x P(x) is true If at a step P(x) is false, then ∀x P(x) is false and the loop terminates To evaluate ∃x P(x) loop through all xin the domain If at some step, P(x) is true, then ∃x P(x) is true and the loop terminates If the loop ends without finding an xfor which P(x) is true, then ∃x P(x) is false Even if the domains are infinite, we can still think of the quantifiers this fashion, but the loops will not terminate in some cases. Conjunctions and Disjunctions 合取、析取If the domain is finite, a universally quantified proposition is equivalent to a conjunction of propositions without quantifiers and an existentially quantified proposition is equivalent to a disjunction of propositions without quantifiers. If U consists of the integers 1,2, and 3 $∀x P(x) ≡ P(1) ∧ P(2) ∧ P(3)​$ $∃x P(x) ≡ P(1) ∨ P(2) ∨ P(3)​$ Even if the domains are infinite, you can still think of the quantifiers in this fashion, but the equivalent expressions without quantifiers will be infinitely long. Other Quantifiers 其他量词 Uniqueness quantifier 唯一性量词 $∃!$ or $∃_1​$ ∃!x P(x) means that P(x) is true for one and only one x in the universe of discourse. Precedence of Quantifiers 量词优先级The quantifiers ∀and ∃have higher precedence than all the logical operators. Binding Variables 量词绑定Bound Variable 约束的量词a variable is bound if it is known or quantified. Free Variable 自由的量词a variable neither quantified nor specified with a value All the variables that occur in a propositional function must be bound or set equal to a particular value to turn it into a proposition. In the statement ∃x(x + y = 1), the variable x is bound by the existential quantification ∃x, but the variable y is free because it is not bound by a quantifier and no value is assigned to this variable. This illustrates that in the statement ∃x(x + y = 1), x is bound, but y is free. However, this statement is not a proposition since y is undefined and we can’t tell whether it is true or false. Logical Equivalences Involving Quantifiers 涉及量词的逻辑等价式Statements involving predicates and quantifiers are logically equivalent iff they have the same truth x is not occuring in P 量词辖域的扩张 $∀xP(x)∨A ≡ ∀x(P(x)∨A)​$ $∀xP(x)∧A ≡ ∀x(P(x)∧A)​$ $∃xP(x)∨A ≡ ∃x(P(x)∨A)​$ $∃xP(x)∧A ≡ ∃x(P(x)∧A)​$ 量词辖域的收缩 $∀x(A→P(x)) ≡ A→∀xP(x)​$ $∃x(A→P(x)) ≡ A→∃xP(x)​$ （下面的两个式子很重要） $∀x(P(x)→A) ≡ ∃xP(x)→A​$ $∃x(P(x)→A) ≡ ∀xP(x)→A$ Negating Quantified Expressions 量化表达式的否定De Morgan’s Laws for Quantifiers 量词的德·摩根律$¬∀x P(x) ≡ ∃x ¬P(x)​$ $¬∃x P(x) ≡ ∀x ¬P(x)​$ Negation Equivalent Statement When is Negation True? When False? $¬∃x P(x)$ $∀x ¬P(x)$ P(x) is false for every x There is an x for which P(x) is true $¬∀x P(x)$ $∃x ¬P(x)$ There is an x for which P(x) is false P(x) is true for every x Translating from English into Logical ExpressionsThe very first step is to decide on the domain U. Translate the following sentence into predicate logic“Every student in this class has taken a course in Java.” First decide on the domain U. Solution 1If U is all students in this class, define a propositional function J(x) denoting “x has taken a course in Java” and translate as ∀x J(x). Solution 2But if U is all people, also define a propositional function S(x) denoting “x is a student in this class” and translate as ∀x (S(x)→ J(x)). A Very Important Notice!!! Every student in this class has taken a course in Java if U is all people, also define a propositional function S(x) denoting “x is a student in this class” $∀x (S(x) ∧J(x))​$ is not correct!!! if there is one x that does not belong to this class, then the whole statement is false! Some student in this class has taken a course in Java if U is all people $∃x (S(x)→ J(x))$ is not correct!!! if there is one x that does not brlong to this class, the the whole statement is true! Premises and Conclusion 前提和结论Lewis Carroll Example An argument “All lions are fierce.” “Some lions do not drink coffee.” “Some fierce creatures do not drink coffee.” The first two are called premises（前提） and the third is called the conclusion（结论）.The entire set is called an argument（论证）. One way to translate these statements to predicate logic Let p(x), q(x), and r(x) be the propositional functions “xis a lion,” “xis fierce,” and “xdrinks coffee,” respectively. Domain of x: All creatures. ∀x (p(x)→ q(x)) ∃x (p(x) ∧¬r(x)) ∃x (q(x) ∧¬r(x)) Later we will see how to prove that the conclusion follows from the premises. Nested Quantifiers 嵌套量词Definition 定义Two quantifiers are nested if one is within the scope of the other. e.g. $∀x∃yC(x,y)​$ Translating from Nested Quantifiers into English Translate the statement $∀x(C(x)∨∃y(C(y)∧F(x,y)))$ into English, where C(x) is “x has a computer,” F(x,y) is “x and y are friends,” and the domain for both x and y consists of all students at ZJU. Solution Use variables in the translatint result (Easy and clear) For every student x at ZJU, x has a computer or there is a student y such that y has a computer and x and y are friends. Understand the meaning and report it in English Every student at ZJU has a computer or has a friend who has a computer. Translating English into Logical Expressions Involving Nested Quantifiers Express the statement “Everyone has exactly one best friend” as a logical expression with a domain consisting of all people Solution Rewrite the original statement as For every person x , x has exactly one best friend. There is a person y who is the best friend of x, and furthermore, that for every person z, if z is not y, then z is not the best friend of x. Let B(x, y) be the statement y is the best friend of x. $∀x∃y∀z(B(x,y)∧((z≠y)→¬B(x,z)))​$ The Order of Quantifiers 量词顺序The order of nested quantifiers matters if quantifiers are of different types e.g. $∀x∀yP(x,y) ≡ ∀y∀xP(x,y)$ However $∃x∀yP(x,y)​$ is not the same as $∀y∃xP(x,y)​$ Explanation Assume P(x,y) denote “x loves y“, where the domain for variables x and y consists of all people $∃x∀yP(x,y)$ —&gt; There is someone who loves everyone. $∀y∃xP(x,y)$ —&gt; Everybodyi s loved by somebody. Negating Nested Quantifiers 嵌套量词的否定Negating nested quantifiers by successively applying the rules for negating statements involving a single quantifier e.g. Quantifications of Two Variables 两个变量的量化式 Statement When True? When False? $∀x∀yP(x, y)\\∀y∀xP(x, y)$ P(x, y) is true for every pair x, y. There is a pair x, y for which P(x, y) is false. $∀x∃yP(x, y)$ For every x there is a y for which P(x, y) is true. There is an x such that P(x, y) is false for every y. $∃x∀yP(x, y)$ There is an x for which P(x, y) is true for every y. For every x there is a y for which P(x, y) is false. $∃x∃yP(x, y)\\∃y∃xP(x, y)$ There is a pair x, y for which P(x, y) is true. P(x, y) is false for every pair x, y.","categories":[],"tags":[{"name":"Discrete Math","slug":"Discrete-Math","permalink":"https://ncj.wiki/tags/Discrete-Math/"}]},{"title":"【DM】CH01-01 Proposition Logic and Propositional Equivalences","slug":"DM/CH01_Logic_and_Proofs/CH01_01_Proposition_Logic_and_Propositional_Equivalences","date":"2019-03-10T11:45:29.000Z","updated":"2019-09-05T13:38:45.733Z","comments":true,"path":"2019/03/10/DM/CH01_Logic_and_Proofs/CH01_01_Proposition_Logic_and_Propositional_Equivalences/","link":"","permalink":"https://ncj.wiki/2019/03/10/DM/CH01_Logic_and_Proofs/CH01_01_Proposition_Logic_and_Propositional_Equivalences/","excerpt":"","text":"Chapter 01 Logic and Proofs 逻辑与证明 Part 01 Proposition Logic and Propositional Equivalences Covering1.1 ~ 1.3 Proposition Logic 命题逻辑 Knowledge Frame 知识框架 Proposition 命题 Connectives 联结 (命题之间的关联) Negation (NOT) 否定 Conjunction (AND) 合取 Disjunction (OR) 析取 Exclusive Or (XOR) 异或 Implication (if-then) 蕴含 Converse, Contrapositive, and Inverse 逆命题、逆否命题、否命题 Biconditional (if and only if) 双条件 Precedence 优先级 Truth Table 真值表 (一个工具) Equivalent Propositions 等价命题 Bit Operations 位运算 Proposition 命题 A proposition is a declarative sentence that is either true or false, but not both. 命题是一个陈述语句，它或真或假，但不能既真又假。 不是命题的几种典型反例 command 命令 (e.g. Read it loud!) question 疑问 (e.g. What time is it?) paradox 悖论 (e.g. This statement is false.) equation with unknowns 含有未知数的等式 (e.g. x + y = z) 使用字母来表示命题变元(propositional variables) Connectives 联结Negation (NOT) 否定The negation of a proposition p : ¬p (not p) Conjunction (AND) 合取The conjunction of propositions p and q : p ∧ q (p and q) Note: The sun is shining , but it is raining. 自然语言和逻辑语言是有区别的，不要混为一谈。这一点在之后还会出现！ Disjunction (OR) 析取The disjunction of propositions p and q : p ∨ q (p or q) Exclusive Or (XOR) 异或the exclusive or of p and q : p ⊕ q (True when exactly one of p and q is true.) Note: ∨ vs. ⊕ Inclusive or: ∨ Exclusive or: ⊕ Implication (if-then) 蕴含Implication or conditional statement : p → q (if p, then q) Note: 再次注意，自然语言和逻辑语言是有区别的，生活中的逻辑也不要强行带入 e.g. If the moon is made of green cheese, then I have more money than Bill Gates. 这句话的真值为T Different Ways of Expressing p → q大部分直接读读就知道了，但是有两个很坑 p only if q q unless ¬p 思考它们的最佳办法就是带入一个实例 e.g. Mary will eat the fruit only if the fruit is apple. p : Mary will eat the fruit q : the fruit is apple if (Mary will eat the fruit), then (the fruit is apple) if p, then q in English, not unless = only if Converse, Contrapositive, and Inverse 逆命题、逆否命题、否命题 p → q Implication q → p Converse ¬q → ¬p Contrapositive ¬p → ¬q Inverse Biconditional (if and only if) 双条件the biconditional proposition : p ↔ q (p if and only if q, p iff q, vice versa) Precedence 优先级 Operator Precedence ¬ 1 ∧ ∨ 2 3 → ↔ 4 5 Truth Table 真值表真值表是研究命题逻辑的重要工具 在构建真值表时，其实就是在手工模拟计算机枚举的过程 不难，仅以一题为例 An island has two kinds of inhabitants, knights, who always tell the truth, and knaves, who always lie. You go to the island and meet A and B. A says “B is a knight.” B says “The two of us are of opposite types.” What are the types of A and B? Let p: “A is a knight” ​ q: “B is a knight” p q p ↔ q q ↔ p ⊕ q T T T F T F F F F T F T F F T T So the answer is that both A and B are knaves. Equivalent Propositions 等价命题Two propositions are equivalent if they always have the same truth value. Two Related ProblemsHow many rows are there in a truth table with npropositional variables?$2^n$ With n propositional variables, we can construct ( ) distinct (i.e., not equivalent) propositions$2^{2^n}​$ 稍加解释一下，有n个命题变量时，真值表就有了$2^n$种情况，而每一个命题对于每一种情况，它都可以有T和F两个值（注意，如果两个命题在这$2^n$个情况之下真值完全相同，则它们被视为完全等价的两个命题，即在这里被算为一个）那么此时，就有了$2^{2^n}$种不同的真值组合，对应$2^{2^n}$种不同的命题 Bit Operations 位运算 Bit: a symbol with two possible values , namely, 0 and 1. Boolean variable: one whose value is either true or false. A bit string is a sequence of zero or more bits Bitwise operations are bit operations extended to bit strings. （按位X） Propositional Equivalences 命题等价式Tautologies, Contradictions, and Contingencies 永真、永假、可能式Tautologies 永真 （重言式）A tautology is a proposition which is always true. e.g. p ∨ ¬p Contradictions 永假 （矛盾式）A contradiction is a proposition which is always false. e.g. p ∧ ¬p Contingencies 可能式A contingency is a proposition which is neither a tautology nor a contradiction, such as p Logical Equivalences 逻辑等价式The compound propositions p and q are called logically equivalent if p ↔ q is a tautology. Notation 记号p ⇔ q or p ≡ q Remark The symbol ≡ is not a logical connective, and p ≡ q is not a compound proposition but rather is the statement that p ↔ q is a tautology. Laws 一些等价定律De Morgan’s Laws 德·摩根律 ¬(p ∧ q) ≡ ¬p ∨ ¬q ¬(p ∨ q) ≡ ¬p ∧ ¬q The Extended Version of De Morgan’s Laws 德·摩根律拓展形式$¬(p_1 ∧ p_2 ∧ … ∧ p_n) ≡ ¬p_1 ∨ ¬p_2 ∨ … ∨ ¬p_n$ $¬(p_1 ∨ p_2 ∨ … ∨ p_n) ≡ ¬p_1 ∧ ¬p_2 ∧ … ∧ ¬p_n$ We will sometimes use the notation $\\bigvee{j = 1}^{n} p_j$ for $p_1 \\vee p_2 \\vee … \\vee p_n$ and $\\bigwedge{j = 1}^n pj$ for $p_1 \\wedge p_2 \\wedge … \\wedge p_n$. Using this notation, the extended version of De Morgan’s laws can be written concisely as $\\lnot (\\bigvee{j = 1}^n pj) \\equiv \\bigwedge{j = 1}^n pj $ and $\\lnot (\\bigwedge{j = 1}^n pj) \\equiv \\bigvee{j = 1}^n \\lnot p_j$. (Methods for proving these identities will be given in Section 5.1) Key Logical Equivalences 重要的逻辑等价式 Name Equivalences Identity laws $p \\wedge T \\equiv p, p \\vee F \\equiv p$ Domination laws $p \\vee T \\equiv T, p \\wedge F \\equiv F$ Idempotent laws $p \\vee p \\equiv p, p \\wedge p \\equiv p$ Double negation law $\\lnot \\lnot p \\equiv p$ Commutative laws $p \\vee q \\equiv q \\vee p, p \\wedge q \\equiv q \\wedge p$ Associative laws $(p \\vee q) \\vee r \\equiv p \\vee (q \\vee r), (p \\wedge q) \\wedge r \\equiv p \\wedge (q \\wedge r)$ Distributive laws $p \\vee (q \\wedge r) \\equiv (p \\vee q) \\wedge (p \\vee r), p \\wedge (q \\vee r) \\equiv (p \\wedge q) \\vee (p \\wedge r)$ De Morgan’s laws $\\lnot (p \\wedge q) \\equiv \\lnot p \\vee \\lnot q, \\lnot (p \\vee q) \\equiv \\lnot p \\wedge \\lnot q$ Constructing New Logical Equivalences 构建新的逻辑等价式Using Truth TablesEasy but time-consuming when the number of variables is large Using already-proved equivalencesJust like what we do in Algebra 推理逻辑的基础——传递性$A_1 ≡ A_2$ $A_2 ≡ A_3$ …… $A_{n-1} ≡ A_n$ Samples of Equivalence Proofs Propositional Satisfiability 命题的可满足性A compound proposition is satisfiable if there is an assignment of truth values to its variables that make it true. (成真赋值) When no such assignments exist, the compound proposition is unsatisfiable. Application Sudoku 数独 详见书本 Others 其他Other Logical OperatorsSheffer stroke | （Sheffer 竖）p | q ≡ ¬(p ∧ q) NAND 与非 Peirce arrow ↓ （Peirce 箭头）p ↓ q ≡ ¬(p ∨ q) NOR 或非 p ↓ p ≡ ¬p (p ↓ q) ↓ (p ↓ q) ≡ p ∨ q The Dual of a Compound Proposition 对偶 Functionally Complete Collection of Logical Operators 功能完备的逻辑连接词集合A collection of logical operators is called functionally complete if every compound proposition is logically equivalent to a compound proposition involving only these logical operators. e.g. {¬, ∧, ∨, →, ↔}, {¬, ∧, ∨}, {¬, ∧}, {¬, ∨}, {|}, {↓} are all functionally complete operators","categories":[],"tags":[{"name":"Discrete Math","slug":"Discrete-Math","permalink":"https://ncj.wiki/tags/Discrete-Math/"}]},{"title":"整数划分问题归纳","slug":"2019-02-23_Division","date":"2019-02-23T14:05:37.000Z","updated":"2019-09-05T13:38:45.731Z","comments":true,"path":"2019/02/23/2019-02-23_Division/","link":"","permalink":"https://ncj.wiki/2019/02/23/2019-02-23_Division/","excerpt":"","text":"刷DP题目时遇到了一些整数划分问题，发现它们的思路有一些共通之处，在这里进行一个简要汇总。 一、简单的整数划分问题 将正整数n表示成一系列正整数之和，$n=n_1+n_2+…+n_k$, 其中$n_1 \\geq n_2 \\geq … \\geq n_k \\geq 1$ ，$k \\geq 1$ 。 正整数n的这种表示称为正整数n的划分。 正整数n的不同的划分个数称为正整数n的划分数。 求给定的数n的划分数。 （百练4117） 思路遇到这种题第一反应是DP，然后想能否用一个一维数组以线性复杂度解决。稍加思索发现不行，于是尝试二维数组，增加一个限定条件，细化当前状态。 这里我们增加的维度是划分出的数字的最大值的上限，即构建状态(i, j)，用于描述将数字$i$划分、且划分出的数字的最大值不超过$j$。 状态转移方程dp(i,j)= \\begin{cases} dp(i,i)& \\text{i < j}\\\\ 1 + dp(i,i - 1)& \\text{i = j}\\\\ dp(i,j - 1) + dp(i - j, j)& \\text{i > j} \\end{cases}​稍微解释一下—— $i &lt; j$ 时，最大值上限超过所有数之和，显然没有意义，它直接等价于最大值等于$i$的情况； $i &gt; j$ 时，考虑两类——第一类是该最大值$j$一定出现的情况，也即$dp(i - j,j)$，第二类是最大值$j$一定不出现的情况，即最大值变为$j - 1$，也即$dp(i,j - 1)$； $i = j$ 时，其实与$i &gt; j$ 的情况相同，只是在程序中直接单独判断可以省去为$dp(0,j)​$进行初始化的步骤，稍微降低一点复杂度。 示例代码（递归）int divide(int n, int m)&#123; int res; if (n == 1 || m == 1) res = 1; else if (n &lt; m) res = divide(n, n); else if (n == m) res = 1 + divide(n, n - 1); else res = divide(n, m - 1) + divide(n - m, m); return res;&#125;...divide(n, n); // 调用 二、N划分成K个正整数之和 举个例子 当N = 5，K = 2，则有 5 = 4 + 1 = 3 + 2 所以此时的划分数为2 （百练4119） 思路用dp(i, j)表示i分解为j个数这一状态。 状态转移方程dp(i,j)= \\begin{cases} dp(i - 1,j - 1) + dp(i - j, j)& \\text{i < j}\\\\ 1& \\text{i = j} \\end{cases}​$i &lt; j$ 时，状态分为一定有1和一定无1两种。一定有1时，先分出一个1，问题转化为将$i - 1$分解为$j - 1$个数；一定无1时，先给j给数每个数先分配一个1，再进行正常分配，问题转化为将$i - j$分解为$j$个数。 $i = j$ 时，只能分解为一堆1，故直接等于1。（不过也可以先将$dp(0,j)$都置为0，将$dp(1,1)$置为1，略麻烦） 示例代码（递推）for (int i = 1; i &lt;= 50; i++)&#123; // f[n][k]-&gt;n分解为k个数 for (int j = 1; j &lt; i; j++) f[i][j] = f[i - 1][j - 1] + f[i - j][j]; // 有1 + 无1 f[i][i] = 1;&#125;int res = f[n][k]; // 答案 三、N划分成若干个不同正整数之和 5 = 5 = 4 + 1 = 3 + 2 （百练4119） 思路构建状态(i, j)，用于描述将数字$i$划分、且划分出的数字的最大值不超过$j$ 状态转移方程dp(i,j)= \\begin{cases} dp(i, i)& \\text{i < j}\\\\ dp(i, i - 1) + 1& \\text{i = j}\\\\ dp(i, j - 1) + dp(i - j, j - 1)& \\text{i > j} \\end{cases}​$i &gt; j$ 时，分为无j和有j两类（和最开始的思路很类似），唯一的区别在于无j时转化为$dp(i - j, j - 1)$，原因很简单，这里的数字不能重复，所以必须要求分出一个j后，其他数字最大值不超过$j - 1$。 其余基本一样，不解释。 示例程序（递推）for (int i = 1; i &lt;= 50; i++)&#123; for (int j = 1; j &lt; i; j++) g[i][j] = g[i][j - 1] + g[i - j][j - 1]; // 无j + 有j g[i][i] = g[i][i - 1] + 1; for (int j = i + 1; j &lt;= 50; j++) g[i][j] = g[i][i];&#125;int res = g[n][n]; // 答案 四、N划分成若干个奇正整数之和 5 = 5 = 1 + 1 + 3 = 1 + 1 + 1 + 1 + 1 + 1 （百练4119） 思路其实这和第一个问题差不多，只是需要保证划分的方案全是奇数。 状态转移方程奇数时，同问题一。 偶数时，dp(i, j) = dp(i, j - 1) 具体细节看代码好了。 示例代码（递推）for (int i = 0; i &lt;= 50; i++)&#123; dp[i][1] = 1; if (i &amp; 1) dp[0][i] = 1; // 预处理第0层&#125;for (int i = 1; i &lt;= 50; i++)&#123; for (int j = 1; j &lt;= 50; j++) &#123; if (j &amp; 1) if (j &lt;= i) dp[i][j] = dp[i - j][j] + dp[i][j - 1]; // 同一般情况分解 else dp[i][j] = dp[i][i]; else dp[i][j] = dp[i][j - 1]; &#125;&#125;int res = dp[n][n]; // 答案 五、回文序列划分问题Unimodal Palindromic Decompositions ZOJ1353 A sequence of positive integers is Palindromic if it reads the same forward and backward. For example: 23 11 15 1 37 37 1 15 11 23 1 1 2 3 4 7 7 10 7 7 4 3 2 1 1 A Palindromic sequence is Unimodal Palindromic if the values do not decrease up to the middle value and then (since the sequence is palindromic) do not increase from the middle to the end For example, the first example sequence above is NOT Unimodal Palindromic while the second example is. A Unimodal Palindromic sequence is a Unimodal Palindromic Decomposition of an integer N, if the sum of the integers in the sequence is N. For example, all of the Unimodal Palindromic Decompositions of the first few integers are given below: 1: (1)2: (2), (1 1)3: (3), (1 1 1)4: (4), (1 2 1), (2 2), (1 1 1 1)5: (5), (1 3 1), (1 1 1 1 1)6: (6), (1 4 1), (2 2 2), (1 1 2 1 1), (3 3), (1 2 2 1), ( 1 1 1 1 1 1)7: (7), (1 5 1), (2 3 2), (1 1 3 1 1), (1 1 1 1 1 1 1)8: (8), (1 6 1), (2 4 2), (1 1 4 1 1), (1 2 2 2 1), (1 1 1 2 1 1 1), ( 4 4), (1 3 3 1), (2 2 2 2), (1 1 2 2 1 1), (1 1 1 1 1 1 1 1) Write a program, which computes the number of Unimodal Palindromic Decompositions of an integer. Input Input consists of a sequence of positive integers, one per line ending with a 0 (zero) indicating the end. Output For each input value except the last, the output is a line containing the input value followed by a space, then the number of Unimodal Palindromic Decompositions of the input value. Sample Input 2345678102324131213920 Sample Output 2 23 24 45 36 77 58 1110 1723 10424 199131 5010688213 105585259092 331143 思路这题的状态转移思路与问题二很像。 首先用dp[i][j]表示i分解为j个数字的情况数目 特殊情况暂且不管，对于一般的i,j，分为边缘元素 &gt; 1 和 边缘元素 = 1两种情况（边缘元素指两边的元素） 边缘元素 &gt; 1时，就给每个元素先分配一个1，再将余下的i - j分配给j个数 边缘元素 = 1时，就先在两边各分配一个1，再将余下的i - 2分配给j - 2个数 状态转移方程$dp(i,j) = dp(i - j, j) + dp(i - 2, j - 2)​$ 示例代码（递推）dp[i][1] = 1; // dp[i][j] -&gt; i divided into j numbers dp[i][2] = (i % 2 == 0);for (int j = 3; j &lt;= i; j++) dp[i][j] = dp[i - j][j] + dp[i - 2][j - 2]; // (side_elements &gt; 1) &amp; (side_elements = 1)for (int j = 1; j &lt;= i; j++) ans[i] += dp[i][j]; // 答案 六、代码优化递归方法记忆化，不多说 递推方法对于多组测试数据的题目，建议先用递归打表，把范围内所有数的结果都算出来（因为算最大值时也会用到前面的结果），之后直接按需输出就好了 个人觉得递推更好，毕竟递归调用函数也有开销；不过对于多测试点的情况，如果递推不打表的话，可能反而比递归慢，因为每次都重算了一遍。递推打表打太多也不划算……还是具体问题具体选择好了…… st=>start: dp(i,j) cond=>condition: 最大值上限j是否为奇数 c2=>end: 与问题一等价 c3=>end: dp(i,j) = dp(i,j-1) st->cond cond(yes)->c2 cond(no)->c3{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-0-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-0-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-0\", options);","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://ncj.wiki/tags/Algorithm/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://ncj.wiki/tags/Dynamic-Programming/"}]},{"title":"【预告&Flag】离散数学详解","slug":"2019-02-20_a_flag_about_Discrete_Mathematics","date":"2019-02-19T15:45:49.000Z","updated":"2019-09-05T13:38:45.731Z","comments":true,"path":"2019/02/19/2019-02-20_a_flag_about_Discrete_Mathematics/","link":"","permalink":"https://ncj.wiki/2019/02/19/2019-02-20_a_flag_about_Discrete_Mathematics/","excerpt":"","text":"这学期就要学离散了，准备和室友一起尝试着在GitHub上建立一个项目，内容就是离散数学。我们计划每周将笔记、总结、部分课本内容的翻译（没错，我们用的是全英文教材）commit到上面。 Flag立在这里，项目地址搁这，也算是让大家来监督我们。 同时欢迎各位同仁PR https://github.com/iamNCJ/Discrete_Mathematics_Explained_in_Detail","categories":[],"tags":[{"name":"Flag","slug":"Flag","permalink":"https://ncj.wiki/tags/Flag/"}]},{"title":"C语言的宏运算符","slug":"2019-02-19_Macro","date":"2019-02-19T15:06:08.000Z","updated":"2019-09-05T13:38:45.730Z","comments":true,"path":"2019/02/19/2019-02-19_Macro/","link":"","permalink":"https://ncj.wiki/2019/02/19/2019-02-19_Macro/","excerpt":"","text":"这题还是MSC决赛的一题，原题题干已经交代得很清楚了（我懒……），直接搬过来好了 宏&amp;宏函数简介宏是 C 语言中极为强大，也极具魅力的一个功能。宏为极其贴近机器语言的 C 提供了一定程度上的元编程能力。程序员们能够利用宏来减少代码中的重复，或是解决一些条件编译之类的问题。 宏、或者说 C 预处理器，实际上干的事情就是进行字符串拼接和处理，其中比较简单的就是普通的字符串替换： #define abc efg#define one 1#define INT int#define DENGYUINT abc DENGYU one; // -&gt; int efg = 1; 为了防止替换的过程无法结束，通过这种方式定义的宏在它的(和它的递归)展开内容中是不会再对其本身进行替换 #define abc abc efg#define efg abc hij#define hij efg abc abc // (所有东西都可以被展开)-&gt; abc efg // (abc 不会再被展开)-&gt; abc abc hij // (abc efg 不会再被展开)-&gt; abc abc efg abc 另一种则是宏函数，规则稍微复杂一些。宏函数首先会对它的参数进行宏展开，如果参数中存在 # 或者 ## (具体作用后面会提及)， 那么不再对这个参数进行递归展开，然后再按照宏的定义将参数进行拼接，得到这一次展开的结果；之后对结果进行下一次展开。这次展开和之前说的展开规则类似，不再会对生成的结果中相同的宏函数进行展开。 #define foo(a, b) a bfoo(1+, 2) // -&gt; 1 + 2#define foo2(a, b) foo(a) foo(b)foo2(1+, 2) // -&gt; foo(1+) foo(2) -&gt; 1+ 1+ 2 2 C 预处理器提供了一些方法来生成特殊的字符串，例如 # 和 ##. ## 能将它两边的内容直接连接起来，去除中间的空格，可以用来拼接新的宏或者标识符等 #define CONCAT(X, Y) X ## Yint a = CONCAT(x, 1); // -&gt; int a = x1;#define ADD_PREFIX_AND_SUFFIX(X) pre ## X ## sufint b = ADD_PREFIX_AND_SUFFIX(X); // int a = preXsuf;#define IF(COND, PASS, FAIL) IF_ ## COND (PASS, FAIL)#define IF_0(PASS, FAIL) FAIL#define IF_1(PASS, FAIL) PASSIF(0, A, B) // -&gt; BIF(1, A, B) // -&gt; A # 能作用于它右边的宏参数，把它转化为一个 C 语言字符串字面量。而 C 语言也提供了“自动拼接相邻两个字符串字面量”的语法糖，使得我们可以在 编译期完成拼接字符串字面量的操作 #define TO_C_STR(X) #X#define ADD_C_STR_SUFFIX(X, Y) X TO_C_STR(Y)const char* c_str = ADD_C_STR_SUFFIX(\"abc\", efg); // -&gt; const char* c_str = \"abc\" \"efg\"; === const char* c_str = \"abcefg\"; 宏也提供了可变参数的宏函数。简单的说，配合 __VA_ARGS__ 它可以将传入的参数按原样替换到内容里。 相比与 C 语言的可变参数函数，宏函数不需要”至少有一个固定参数”。 在宏函数的替换内容中，可以使用 __VA_ARGS__ 来代表它获得的可变参数. 可以使用 , ##__VA_ARGS__来实现对 0 个可变参数的适配。可变参数 ... 只能在参数列表中出现一次。 下面是一些例子： #define PRINT(...) printf(__VA_ARGS__)#define PRINTF(FMT, ...) printf(FMT, ##__VA_ARGS__)PRINT(\"123\"); // -&gt; printf(\"123\");PRINT(\"%d\", 1); // -&gt; printf(\"%d\", 1);PRINTF(\"123\"); // -&gt; printf(\"123\");PRINTF(\"%d\", 1); // -&gt; printf(\"%d\", 1); 宏函数有什么用？ 偶读翁恺老师博客上的文章，看到这样一篇 在讲到编译预处理指令的宏运算符##时，同学们都不太理解这东西有什么用。今天恰好在Arduino的Ethernet库的头文件里看到了活的例子。在Arduino的Ethernet库的w5100.cpp里有这样的函数调用： writeTMSR(0x55); 但是遍寻整个.cpp和对应的w5100.h也找不到这个writeTMSR()函数，即使把所有的源代码目录拿来搜索一遍都没有。但是，编译显然是通过了的，那么，这个函数在哪里呢？ 在w5100.h，我们发现了这样的代码： #define __GP_REGISTER8(name, address) \\ static inline void write##name(uint8_t _data) &#123; \\ write(address, _data); \\ &#125; \\ static inline uint8_t read##name() &#123; \\ return read(address); \\ &#125; 这个宏定义是说，如果你提供一个name和一个address，那么宏__GP_REGISTER8就会被展开为两个函数，一个的名字是write后面跟上name，另一个是read后面跟上name。 于是，在w5100.h里接下去的代码： __GP_REGISTER8 (TMSR, 0x001B); // Transmit memory size 在编译预处理后，就会被展开成为： static inline void writeTMSR(uint8_t _data) &#123; write(0x001B, _data); &#125; static inline uint8_t readTMSR() &#123; return read(0x001B); &#125; 看，这就是活生生的宏运算符的例子。 宏函数的技巧性使用题目-MAX() 题目描述实现一个可以接受可变参数的宏函数 MAX, 它返回其中的最大值。 保证传入的参数为合法的 C 表达式，且类型为 int，个数在 1 ~ 5 之间，中间用逗号分隔 保证传入的表达式无副作用 函数接口定义虽然并不是函数 &gt; #define MAX(...)&gt; &gt; 裁判测试程序样例&gt; #include &lt;stdio.h&gt;&gt; &gt; // your code here&gt; &gt; int data[10];&gt; &gt; int main() &#123;&gt; int n;&gt; scanf(\"%d\", &amp;n);&gt; int x, y, z, w, u;&gt; switch(n) &#123;&gt; case 1: scanf(\"%d\", &amp;x); printf(\"%d\\n\", MAX(x)); break;&gt; case 2: scanf(\"%d %d\", &amp;x, &amp;y); printf(\"%d\\n\", MAX(x, y)); break;&gt; case 3: scanf(\"%d %d %d\", &amp;x, &amp;y, &amp;z); printf(\"%d\\n\", MAX(x, y, z)); break;&gt; case 4: scanf(\"%d %d %d %d\", &amp;x, &amp;y, &amp;z, &amp;w); printf(\"%d\\n\", MAX(x, y, z, w)); break;&gt; case 5: scanf(\"%d %d %d %d %d\", &amp;x, &amp;y, &amp;z, &amp;w, &amp;u); printf(\"%d\\n\", MAX(x, y, z, w, u)); break;&gt; default: break;&gt; &#125;&gt; return 0;&gt; &#125;&gt; &gt; 样例仅供参考 样例1输入&gt; 4 1 3 2 1&gt; &gt; 输出&gt; 3&gt; &gt; 样例2输入&gt; 1 0&gt; &gt; 输出&gt; 0&gt; &gt; 提示 具体的规则最好自己实验一下， 使用 gcc -E test.c 可以打印出 test.c 经过预处理后的代码 宏函数的参数使用时在不影响语义的情况下尽量在两边加上 () ，一个常见的错误例子就是： &gt; #define MUL(A, B) A * B&gt; MUL(1 + 2, 3 + 4) // -&gt; 1 + 2 * 3 + 4 &gt; &gt; 在预处理器进行处理的过程中, 可以产生一些临时参数，但它们很快就在下一次替换过程消失，而不会导致生成非法的表达式。 你可能需要一个形式类似于 #define FOO(_USELESS_PARAMETER, ...) BLAHBLAH 的宏 思路&amp;题解我曾经想过将宏函数里的参数全部传到另一个变参函数中（上一篇文章讲的就是变参函数），但是MAX()的实现需要知道参数的个数，而这一点又是变参函数无法实现的（原因见上一篇文章），因此此思路失败。 但是请注意，MAX()的实现需要知道参数的个数，这句话其实提醒了我们，此题的突破口其实就是如何让程序知道参数的个数。 看到这里你要是还没有思路的话，其实太正常了——因为这题技巧性很强，解法也很漂亮。 直接放代码好了，看了代码一定会有豁然开朗的感觉。 #define MAX1(A) (A)#define MAX2(A,B) (A)&gt;(B)?(A):(B)#define MAX3(A,B,C) MAX2(MAX2(A,B),(C))#define MAX4(A,B,C,D) MAX2(MAX3(A,B,C),(D))#define MAX5(A,B,C,D,E) MAX2(MAX4(A,B,C,D),(E))#define GETMAX(A,B,C,D,E,MAXNAME,...) MAXNAME#define MAX(...) GETMAX(__VA_ARGS__,MAX5,MAX4,MAX3,MAX2,MAX1)(__VA_ARGS__) 这里其实就是利用参数个数的不同，使固定位置上获取的参数不同，从而实现基于参数个数的宏函数重载 这解法太骚了不过其局限性在于依然只能处理一定数量以内的参数，这也是此题给出个数在1~5之间的限制的原因。 启示 存在即合理 C语言中有大量对于底层的奇怪操作，尽管看起来奇怪，但是其在特定场合依然有很大作用 多看源码可以学到很多 ##宏运算符的例子就是在Arduino的源码中发现的，由此可见阅读高质量源码的意义之大 阅读大牛的博客可以收获很多 ##宏运算符的例子就是在翁恺老师的博客中发现的…… MSC的语法题差不多说完了，本来计划把其他算法题也谈谈的，但是我最终放弃了，原因有二： 寒假太忙了…… 在接触了许多其他题目后，我意识到决赛时碰到的题目，只是万千算法题中微不足道的几题。算法是一个极其庞大的课题，需要慢慢修炼，因此计划转为系统地整理一套算法笔记。 之后我遇到有意思的题目时，依然会分享在博客上的，敬请关注。","categories":[],"tags":[{"name":"C","slug":"C","permalink":"https://ncj.wiki/tags/C/"},{"name":"Grammar","slug":"Grammar","permalink":"https://ncj.wiki/tags/Grammar/"}]},{"title":"Variadic Function in C","slug":"2019-01-20_variadic-function","date":"2019-01-20T05:22:41.000Z","updated":"2019-09-05T13:38:45.730Z","comments":true,"path":"2019/01/20/2019-01-20_variadic-function/","link":"","permalink":"https://ncj.wiki/2019/01/20/2019-01-20_variadic-function/","excerpt":"","text":"&emsp;&emsp;去年参加MSC的决赛的时候，遇到了关于变参函数的问题。其实这类函数很套路，但是考虑到之后想写的关于宏的一篇文章中有些东西跟变参函数有些类似，而且网上关于变参函数的教程都几乎是千篇一律、不中要害，因此先写一篇关于变参函数的文章，对其使用方法进行探讨。 〇、引言-常规的函数&emsp;&emsp;在C语言中，函数在声明时往往就要指定参数的数量与类型，编译的时候，编译器也会替我们检查，看函数调用有无问题。 &emsp;&emsp;例如： #include &lt;stdio.h&gt;int func(int i, int j)&#123;&#125; int main()&#123; func(100); // 实参数目不对 return 0;&#125; &emsp;&emsp;此时编译器就会报错： error: too few arguments to function 'func'func(100);^ &emsp;&emsp;再如： #include &lt;stdio.h&gt;int func(int i, int j)&#123;&#125;int main()&#123; int* a; func(a, 100); return 0;&#125; &emsp;&emsp;此时编译器不会报错（at least for GCC），但是会给出一个Warning： warning: passing argument 1 of 'func' makes integer from pointer without a cast func(a, 100); ^note: expected 'int' but argument is of type 'int *' int func(int i, int j) ^ &emsp;&emsp;在这里我是故意用的一个指针，如果你用的是double或者char的话，连warning都不会出现，到时候一个强制类型转化塞给func()。 &emsp;&emsp;于是，我们大部分时候接触到的函数就都是这种参数个数、类型都不可变的函数了。 &emsp;&emsp;但其实有一个函数，我们从Hello World就开始用了，而且几乎目前的每个程序里都要用到，而它其实是一个变参函数。 一、printf() scanf() 就是变参函数！&emsp;&emsp;没错，C 语言中最常用的可变参数函数例子其实就是printf()和 scanf()。仔细想想，每次你在调用这两个函数的时候，其后面的参数个数以及类型是不是的确在变化？ &emsp;&emsp;为了进一步了解其实现的机制，我们来看看这两个函数的函数原型。（以TDM-GCC为例） int __cdecl printf(const char * __restrict__ _Format,...);int __cdecl scanf(const char * __restrict__ _Format,...) __MINGW_ATTRIB_DEPRECATED_SEC_WARN; &emsp;&emsp;其中的...就是变参函数中可变参数部分的声明。 二、变参函数的特点&emsp;&emsp;我们来就这两个经典的函数，简要分析一下变参函数的特点。 1）一定要有固定数量的强制参数（mandatory argument）&emsp;&emsp;变参函数必须至少有一个强制参数。 &emsp;&emsp;在这两个函数中，它体现为一个格式化字符串——const char * __restrict__ _Format。 2）省略号（…）代表可选参数&emsp;&emsp;在格式化字符串之后，紧跟着的是一个逗号和三个点构成的省略号。这个省略号代表的就是可选参数。可选参数的类型可以变化。 3）参数列表的格式是强制性参数在前、可选参数在后&emsp;&emsp;如果我强行在可选参数之后再添加一个强制参数，比如下面的一波操作： int sumplus(int count, ..., int m)&#123;&#125; &emsp;&emsp;编译会报错： error: expected ')' before ',' token int sumplus(int count, ..., int m) ^ &emsp;&emsp;一定会有人说，可选参数在最后不应该是天经地义的吗？但是到后面你就会发现我这番尝试并不是空穴来风。 4）编译器和函数并不知道可选参数有多少个&emsp;&emsp;肯定又会有人说，printf() scanf() 不是可以按照后面参数的要求输出、输入吗？确实可以，但是它们真的不知道自己后面有几个参数。 &emsp;&emsp;实验为证： #include &lt;stdio.h&gt;int main()&#123; printf(\"%d\\n\", 100, 200); return 0;&#125; &emsp;&emsp;编译通过： Compilation results...--------- Errors: 0- Warnings: 0 &emsp;&emsp;运行试试？ 100 &emsp;&emsp;杠精会说：嗯，那是printf()自动帮你把后面多的参数扔掉了。 &emsp;&emsp;Really? &emsp;&emsp;依然以实验为证： #include &lt;stdio.h&gt;int main()&#123; printf(\"%d %d %d %d %d %d\\n\", 100, 200); return 0;&#125; &emsp;&emsp;依然编译通过： Compilation results...--------- Errors: 0- Warnings: 0 &emsp;&emsp;再运行试试？ 100 200 17 42 4199400 0 &emsp;&emsp;开始乱码了…… &emsp;&emsp;这就已经充分说明编译器和函数完全不知道你给它了多少给参数。它们完全不知道这些，只是按照一定的规则在试图读取这些可变的参数。那规则是什么呢？答案马上揭晓。 三、实现变参函数的方法0）搬运过来的题目背景介绍 &emsp;&emsp;在 C 调用约定下我们可以使用 va 系列宏来轻松的实现一些变参函数，例如： &gt; #include &lt;stdarg.h&gt;&gt; int sum(int count, ...) &gt; &#123;&gt; va_list args;&gt; va_start(args, count);&gt; int res = 0;&gt; for (int i = 0; i &lt; count; i++) &gt; &#123;&gt; int val = va_arg(args, int);&gt; res += val;&gt; &#125;&gt; va_end(args);&gt; return res;&gt; &#125;&gt; &gt; &emsp;&emsp;代码本身很简单，这里稍微解释。 &emsp;&emsp;va_list args; 定义一个指向可变参数列表的指针 &emsp;&emsp;va_start(args, count); 使参数列表指针指向函数参数 count &emsp;&emsp;va_arg(args, int) 把参数列表指针当前所指位置以类型 int 读取出来并移动参数列表指针 &emsp;&emsp;va_end(args) 清空参数列表。va_start 和 va_end 必须一一对应 。”每次调用va_start() / va_copy()后，必须得有相应的va_end()与之匹配。参数指针可以在参数列表中随意地来回移动，但必须在va_start() … va_end()之内 &emsp;&emsp;当然大家可以发现这种形式的可变参数函数是非常危险的，va_arg 基本就是强制类型转换，而且读取的参数个数也只能通过用户输入来确认，很容易出现访问参数越界的情况。同时 va_arg 取出的参数类型和实际传入的类型不一致，或是访问最后一个参数之后的参数是未定义行为，在不同平台、不同编译器实现下的结果可能不完全相同，所以在使用这些函数的时候也请大家务必注意参数的个数和类型问题。 &emsp;&emsp;这段话不是我写的。我是直接从决赛题的题目背景里搬过来的。其实它讲的已经比较清楚了，网上的各种教程基本上都是这段代码和解释。但是，有几点想与大家探讨一下。 1）关于可变参数的读取个数的问题&emsp;&emsp;最后一段话中其实解释了这个问题：读取的参数个数也只能通过用户输入来确认！ &emsp;&emsp;这就是为什么前面printf()的例子中没有报错的原因了——编译器不会检查函数的参数个数。printf()完全是依赖格式化字符串中的种种要求来读取后面的可变参数的。而这又引发了另一个问题，何时停止读取？——依然依赖格式化字符串中的要求。因此，当格式化字符串中有要求输出、而后面的可变参数中并没有对应参数时，就出现了访问参数越界的情况——这也正是前面输出乱码的原因。 2）关于va_start() va_start(args, count); 使参数列表指针指向函数参数 count &emsp;&emsp;这句话这么说其实不太合适。（刚刚还说这段话讲得比较清楚……，就当是出题人美中不足吧） &emsp;&emsp;要解释清楚va_start(args, count);，我们还是来做实验为好。 #include &lt;stdio.h&gt;#include &lt;stdarg.h&gt;int sumplus(int count, int m, ...) &#123; va_list args; va_start(args, count); int res = 0; for (int i = 0; i &lt; count; i++) &#123; int val = va_arg(args, int); res += val; &#125; va_end(args); return res;&#125;int main()&#123; int a = sumplus(3, 2, 1, 3, 100); printf(\"%d\\n\", a); return 0;&#125; &emsp;&emsp;这段代码编译会有warning： warning: second parameter of 'va_start' not last named argument [-Wvarargs] va_start(args, count); ^ &emsp;&emsp;运行试试？ 104 &emsp;&emsp;这就说明编译之后，参数还是从 ... 的位置开始读取的。（应该是编译器帮忙优化的，自动将指针挪到last named argument那里了） &emsp;&emsp;我们来看看GCC中va_start()的声明。 #define va_start(v,l) __builtin_va_start(v,l) &emsp;&emsp;emmm，意义不大…… &emsp;&emsp;再看看VC6.0中的声明： #define va_start(ap,v) ( ap = (va_list)&amp;v + _INTSIZEOF(v) ) &emsp;&emsp;看来这是将第一个可选参数的地址赋值给ap。（至少在VC6.0里面是这样的） &emsp;&emsp;因此va_start()的作用是使参数列表指针指向第一个可选参数。 &emsp;&emsp;引用一下cplusplus对于va_start()的介绍来证明和完善这一观点。 va_start &gt; void va_start (va_list ap, paramN);&gt; &gt; Initialize a variable argument list Initializes ap to retrieve the additional arguments after parameter paramN. A function that invokes va_start, shall also invoke va_end before it returns. Parameters ap Uninitialized object of type va_list. After the call, it carries the information needed to retrieve the additional arguments using va_arg. If ap has already been passed as first argument to a previous call to va_start or va_copy, it shall be passed to va_end before calling this function. paramN Name of the last named parameter in the function definition. The arguments extracted by subsequent calls to va_arg are those after paramN. 3）关于va_arg() C 语言参数传递时有自动类型提升，char 会被 cast 成 int 再传过去，所以在拿的时候也得拿一个 int &emsp;&emsp;什么意思呢？一会看到实例就明白了。简单说，就是提取可变参数时，所提取的变量类型不一定与其实际类型一致，比如char就需要以int类型的方式读取。 4）关于va_end() 参数指针可以在参数列表中随意地来回移动，但必须在va_start() … va_end()之内 &emsp;&emsp;还记得我在前面提到过的一个看似无用的实验吗？int sumplus(int count, ..., int m)并不能通过编译。但是我为什么会想到去尝试？理由很简单，既然 va_start() 和 va_end() 是成对出现的，那么是否会存在这么一种参数结构，先有几个强制参数，再是可变参数，最后又是几个强制参数，中间调用可变参数时使用 va_start() 和 va_end() ？实验证明这是不允许的，可变参数就是必须放在最后，这是规定与要求。 &emsp;&emsp;可是既然如此，那va_end()意义何在？可以不调用吗？ &emsp;&emsp;老规矩，先做个实验看看： #include &lt;stdarg.h&gt;int sumplus(int count, ...) &#123; va_list args; va_start(args, count); int res = 0; for (int i = 0; i &lt; count; i++) &#123; int val = va_arg(args, int); res += val; &#125;// va_end(args); return res;&#125; &emsp;&emsp;编译通过： Compilation results...--------- Errors: 0- Warnings: 0 &emsp;&emsp;运行也没毛病…… &emsp;&emsp;所以，真的可以省？ &emsp;&emsp;几经周折，在网上找到这么一篇文章（这是原作者的文章，CSDN上面的是转载的，好在还注明了原文地址），建议大家去看看。我这里只引用其中的一部分。 1.不调用可能导致程序崩溃 &emsp;&emsp;从一个使用过va_start()的函数中退出之前，必须调用一次va_end()。&emsp;&emsp;这是因为va_start可能以某种方式修改了堆栈，这种修改可能导致返回无法完成，va_end()能将有关的修改复原。&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;——《C++程序设计语言》 第3版、特别版， p139 2.不调用可能导致内存泄漏 &emsp;&emsp;我们务必记住，在使用完va_list变量后一定要调用宏va_end。&emsp;&emsp;v在大多数C实现上，调用va_end与否并无区别。&emsp;&emsp;但是，某些版本的va_start宏为了方便对va_list的遍历，就给参数列表动态分配内存。&emsp;&emsp;这样一种C实现很可能利用va_end宏来释放此前动态分配的内存；&emsp;&emsp;如果忘记调用宏va_end，最后得到的程序可能在某些机型上没有问题，而在另一些机型上则发生“内存泄露”。&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;——《C陷阱与缺陷》， p161 3.还是不想调用？…… …… 最后，必须在函数返回之前调用va_end，以完成一些必要的清理工作。 &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;——《C程序设计语言》 第2版， p137 ……在所有参数处理完毕后， 且在退出函数f之前，必须调用宏va_end一次 …… &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;——《C程序设计语言》 第2版， p232 &emsp;&emsp;插句题外话：按照规矩办事，其实想得比你重要！看看中国那稀烂的安卓生态吧，不多说了…… 四、自己实现printf()（决赛原题）题目描述 这道题需要你实现一个简单的 printf ，接受一个格式化字符串和若干参数，将结果打印至标准输出。 满足： 使用 &#39;$&#39; 作为转义字符，在需要输出 &#39;$&#39; 字符的时候重复一次 &#39;$&#39; , 其它情况下视为输出对应类型的参数 支持 $d 输出 32 位整数(int)， $s 输出字符串(char*)直至 &#39;\\0&#39; ，$f 输出双精度浮点数 (double), 保留 6 位小数 , $c 输出单个字符 (char)，保证输入合法 返回其中打印的字符个数 保证 &#39;$&#39; 后不会出现上述提及情况以外的字符 函数接口定义&gt; int simple_printf(const char* fmt, ...);&gt; &gt; 其中 fmt 为传入的格式化字符串，... 为传入的其它参数，返回输出的字符串长度 裁判测试程序样例&gt; #include &lt;stdio.h&gt;&gt; #include &lt;stdarg.h&gt;&gt; &gt; int simple_printf(const char* fmt, ...);&gt; &gt; int main() &#123;&gt; printf(\"%d\\n\", simple_printf(\"123 \"));&gt; printf(\"%d\\n\", simple_printf(\"$$ \"));&gt; printf(\"%d\\n\", simple_printf(\"$d \", 123));&gt; printf(\"%d\\n\", simple_printf(\"$c \", '1'));&gt; printf(\"%d\\n\", simple_printf(\"$s \", \"123\"));&gt; printf(\"%d\\n\", simple_printf(\"$f \", 123.4));&gt; return 0;&gt; &#125;&gt; &gt; /**&gt; * your code here&gt; **/&gt; &gt; 保证单次调用输出的长度小于 4096，输出的浮点数保留 6 位小数 输入样例没有输入 输出样例&gt; 123 4&gt; $ 2&gt; 123 4&gt; 1 2&gt; 123 4&gt; 123.400000 11&gt; &emsp;&emsp;虽然我当时一遍就AC了，但是做复杂了（比赛时没有注意到printf()返回值就是打印的字符的个数，自己还单独实现了这个功能…），而且代码也只是能跑而已（比赛…时间很紧……），可读性很差，所以借这个机会重新整理一下好了。 AC代码（标程改编）int simple_printf(const char *fmt, ...)&#123; va_list args; va_start(args, fmt); int counter = 0; while (*fmt != '\\0') &#123; if (*fmt != '$') &#123; putchar(*fmt); fmt++; counter++; continue; &#125; fmt++; if (*fmt == 'd') &#123; // integer int int_val = va_arg(args, int); counter += printf(\"%d\", int_val); fmt++; &#125; else if (*fmt == 'f') &#123; // double double float_val = va_arg(args, double); counter += printf(\"%lf\", float_val); fmt++; &#125; else if (*fmt == 's') &#123; // char* char *str = va_arg(args, char *); counter += printf(\"%s\", str); fmt++; &#125; else if (*fmt == 'c') &#123; // char char cha_val = va_arg(args, int); counter += 1; putchar(cha_val); fmt++; &#125; else if (*fmt == '$') &#123; fmt++; putchar('$'); counter += 1; &#125; &#125; va_end(args); return counter;&#125; &emsp;&emsp;有两点需要注意: &emsp;&emsp;1. C 语言参数传递时有自动类型提升，char 会被 cast 成 int 再传过去，所以在拿的时候也得拿一个 int &emsp;&emsp;这就是刚才提到的关于va_arg()的实例。注意到这样一段代码： else if (*fmt == 'c')&#123; // char char cha_val = va_arg(args, int); counter += 1; putchar(cha_val); fmt++;&#125; &emsp;&emsp;在这里，char需要用int来读取。（char cha_val = va_arg(args, int)) &emsp;&emsp;不过这个很容易发现，因为如果你用char来读取： else if (*fmt == 'c')&#123; // char char cha_val = va_arg(args, char); counter += 1; putchar(cha_val); fmt++;&#125; &emsp;&emsp;编译会有warning… warning: 'char' is promoted to 'int' when passed through '...' char cha_val = va_arg(args, char); ^note: (so you should pass 'int' not 'char' to 'va_arg')note: if this code is reached, the program will abort &emsp;&emsp;运行起来真的abort了…（不同编译器、不同编译选项可能结果不同） 123 4$ 2123 4 &emsp;&emsp;2. 这基本上就是printf()的实现原理了，只不过printf()还可以支持更多的格式化字符串的要求。这也应证了我前面说的：编译器和函数完全不知道你给它了多少给参数。它们完全不知道这些，只是按照一定的规则在试图读取这些可变的参数。 &emsp;&emsp;printf()依照的，就是格式化字符串。 &emsp;&emsp;关于C语言中变参函数的介绍差不多就这些了。自认为是网上最翔实的一篇了，主要还是将自己摸索的过程体现出来。过几天我会再写一篇关于C语言宏的文章，主要谈谈可变参数的宏函数以及宏运算符到底有什么用。希望这两篇文章能对读者有所帮助。","categories":[],"tags":[{"name":"C","slug":"C","permalink":"https://ncj.wiki/tags/C/"},{"name":"Grammar","slug":"Grammar","permalink":"https://ncj.wiki/tags/Grammar/"}]},{"title":"Calculus Review","slug":"2019-01-15_calculus-review","date":"2019-01-15T07:54:13.000Z","updated":"2019-09-05T13:38:45.730Z","comments":true,"path":"2019/01/15/2019-01-15_calculus-review/","link":"","permalink":"https://ncj.wiki/2019/01/15/2019-01-15_calculus-review/","excerpt":"","text":"极限函数&amp;预备知识 参数方程 极坐标方程 二项式展开 和差化积公式 … 数列极限定义$\\xi - N$ （用于验证） 性质&amp;四则运算两大定理&amp;$e$ 夹逼定理 单调有界定理 函数极限定义 $\\xi - \\delta​$ $\\xi - X$ 归结原理、左右极限性质&amp;四则运算两大定理？ 夹逼定理（仍然成立） 单调有界？（No Longer Exist） 两大重要极限 $\\lim_{x \\to 0}\\frac{x}{sinx} = 1$ $\\lim_{x \\to \\infty}(1 + \\frac{1}{x})^x = e​$ 连续定义$\\lim_{x \\to x_0}f(x) = f(x_0)​$ 有限闭区间上的连续函数的性质 有界性 最大最小值定理 零点存在定理 介值定理 （常用于证明$F(\\xi) = 0​$ ) o()、O()、等价替换$o(x) + o(x^2) = o(x)$ $o()$代表”一类“量，因此”=“不是传统意义上的”等于“ 导数定义$\\lim_{x \\to x_0}\\frac{f(x) - f(x_0)}{x - x_0} = A = f’(x_0)$切线割线斜率的极限 $f’(x_0) &gt; 0$ 的意义在$x_0$右边的一小块邻域内，$f(x) &gt; f(x_0)$ 高阶导数 $\\frac{ax + b}{cx + d}$ $x^nf(x)$ $arctan^{(100)}(0)$ $arcsin^{(100)}(0)$ 泰勒 $x^2sinx$求100阶导 其他函数反函数到底对谁求导 复合函数参数方程隐函数微分定义一阶微分的形式不变性 微商 $\\frac{{d}y}{{d}x}​$ 高阶 $\\frac{{d^2}y}{{d}x^2} = \\frac{{d}{(\\frac{{d}y}{{d}x}})}{{d}x}$ 微分定理中值定理极值&amp;凹凸性 极值&amp;费马定理 罗尔定理 拉格朗日中值定理 柯西中值定理 主要用于证明$F’(\\xi) = 0$泰勒定理展开 展开点 带入点 复合函数展开主要用于证明$F’’(\\xi)$ 、$F’’’(\\xi)$给出高阶导数值的点往往是展开点！ 洛必达法则 洛就完了！ 不定积分第一积分换元法凑微分法 调整$dx$ 第二积分换元法去根号 三角换元 整体换$t$ 倒带换分部积分 直接计算 构造循环 形成递推 特殊函数 有理函数 -&gt; 裂项 三角有理函数 -&gt; 万能公式 其他特殊 -&gt; 换元 定积分定义（黎曼和） $\\int_{a}^{b} f(x)dx = \\lim_{x \\to 0^+} \\sum_{i = 1}^{n} f(\\xi_i) \\Delta x_i​$ 分割 取点 求和 求极限 对称和式转化变上限函数的导数 普通 $\\int_{}^{\\phi(x)}​$ $\\int_{}^{x} f(x - y) dy$ -&gt;换元 微积分基本定理不定积分特殊类型 奇偶函数 $\\int{-a}^{a} f(x) dx = \\int{0}^{a} [f(x) + f(- x)]dx$ $\\int{0}^{\\frac{\\pi}{2}}​$ 、 $\\int{0}^{\\frac{\\pi}{4}}​$ 、$\\int_{0}^{\\pi}​$ 换元 其他 反常积分 区间无限 函数无界 应用 数学 物理","categories":[],"tags":[{"name":"Math","slug":"Math","permalink":"https://ncj.wiki/tags/Math/"},{"name":"Calculus","slug":"Calculus","permalink":"https://ncj.wiki/tags/Calculus/"},{"name":"Review Notes","slug":"Review-Notes","permalink":"https://ncj.wiki/tags/Review-Notes/"}]},{"title":"Python3 Learning Notes","slug":"2018-12-31_python3","date":"2018-12-31T15:29:41.000Z","updated":"2019-09-05T13:38:45.729Z","comments":true,"path":"2018/12/31/2018-12-31_python3/","link":"","permalink":"https://ncj.wiki/2018/12/31/2018-12-31_python3/","excerpt":"","text":"Chapter 1 Setupimport this The Zen of Python, by Tim Peters Beautiful is better than ugly.Explicit is better than implicit.Simple is better than complex.Complex is better than complicated.Flat is better than nested.Sparse is better than dense.Readability counts.Special cases aren’t special enough to break the rules.Although practicality beats purity.Errors should never pass silently.Unless explicitly silenced.In the face of ambiguity, refuse the temptation to guess.There should be one— and preferably only one —obvious way to do it.Although that way may not be obvious at first unless you’re Dutch.Now is better than never.Although never is often better than right now.If the implementation is hard to explain, it’s a bad idea.If the implementation is easy to explain, it may be a good idea.Namespaces are one honking great idea — let’s do more of those! Chapter 2 Data Types001 variablesmsg = \"hello\"print(msg) hello 002 string operationsname = \"ada lovelace\"print(name.title())print(name.upper())print(name.lower()) Ada LovelaceADA LOVELACEada lovelace new_msg = msg + \" \" + nameprint ('\\t' + new_msg + '\\n') hello ada lovelace ​ msg_1 = ' hiuf yeb w hviu ywe r 'print(msg_1.rstrip()) hiuf yeb w hviu ywe r msg_1 = msg_1.rstrip()print(msg_1.lstrip()) hiuf yeb w hviu ywe r msg_1 = '\\t' + msg_1 + '\\n'print(msg_1)msg_1 = msg_1.rstrip()print(msg_1)msg_1 = msg_1.lstrip()print(msg_1) hiuf yeb w hviu ywe r hiuf yeb w hviu ywe r hiuf yeb w hviu ywe r 003 number operations10**6 1000000 3/2 1.5 3//2 1 0.1*3 0.30000000000000004 floats’ problems still exists in python3, but it’s common in any language due to how computers save these floats 004 number&amp;stringnum_test_1 = 666print(num_test_1) # print('huvife' + num_test_1 + 'gbtehgbe') # error versionprint('huvife' + str(num_test_1) + 'gbtehgbe') # ornum_test_1 = '666'print('huvife' + num_test_1 + 'gbtehgbe') 666 huvife666gbtehgbe huvife666gbtehgbe Chapter 3 ListThere is no array in Python!!! 001 Introduction to Listsarr = ['vfervewr','gftewgwter','gtewgewwe','gtwgw']print(arr)print(arr[0].title())print(arr[-1]) #see? minus is not only available, but useful!print(arr[-3])message = \"vfsvegeerwsgetrw \" + arr[0] + \" vbgfdbgfrdsbg\"print(message) # message = \"vfsvegeerwsgetrw \" + arr + \" vbgfdbgfrdsbg\" # print(message) # error version [&#39;vfervewr&#39;, &#39;gftewgwter&#39;, &#39;gtewgewwe&#39;, &#39;gtwgw&#39;] Vfervewr gtwgw gftewgwter vfsvegeerwsgetrw vfervewr vbgfdbgfrdsbg &emsp;&emsp;Again, thers is no array in Python! So don’t follow my mistake! (I used ‘arr’ to name a list, because I thought they were the same!) 002 Modifying Listsarr[0] = 'cool'print(arr) [&#39;cool&#39;, &#39;gftewgwter&#39;, &#39;gtewgewwe&#39;, &#39;gtwgw&#39;, &#39;new one&#39;, 666] 003 Add Elementsarr.append('new one')print(arr) [&#39;cool&#39;, &#39;gftewgwter&#39;, &#39;gtewgewwe&#39;, &#39;gtwgw&#39;, &#39;new one&#39;, 666, &#39;new one&#39;] &emsp;&emsp;You can even create an empty list and add elements to it later! motor = []motor.append('honda')motor.append('yamaha')motor.append('suzuki')print(motor) [&#39;honda&#39;, &#39;yamaha&#39;, &#39;suzuki&#39;] 004 Insert Elementsmotor.insert(0,'ducati')print(motor) [&#39;ducati&#39;, &#39;honda&#39;, &#39;yamaha&#39;, &#39;suzuki&#39;] 005 Delete Elementsprint(motor)del motor[1]print(motor) [&#39;ducati&#39;, &#39;honda&#39;, &#39;yamaha&#39;, &#39;suzuki&#39;] [&#39;ducati&#39;, &#39;yamaha&#39;, &#39;suzuki&#39;] 006 Pop Elementsprint(motor)poped_motor = motor.pop()print(motor)print(poped_motor) [&#39;ducati&#39;, &#39;yamaha&#39;, &#39;suzuki&#39;] [&#39;ducati&#39;, &#39;yamaha&#39;] suzuki &emsp;&emsp;This way, you can still use the element you want to delete for the last time.&emsp;&emsp;This is useful! Watch this example! motor = ['ducati', 'honda', 'yamaha', 'suzuki']last_owned = motor.pop()print(\"The last motorcycle I owned was a \" + last_owned.title() + \".\")print(motor) The last motorcycle I owned was a Suzuki. [&#39;ducati&#39;, &#39;honda&#39;, &#39;yamaha&#39;] &emsp;&emsp;And pop can be used to pop any element! motor = ['ducati', 'honda', 'yamaha', 'suzuki']first_owned = motor.pop(0)print(\"The first motorcycle I owned was a \" + first_owned.title() + \".\")print(motor) The first motorcycle I owned was a Ducati. [&#39;honda&#39;, &#39;yamaha&#39;, &#39;suzuki&#39;] 007 Remove Elements According to Its Valuemotor = ['ducati', 'honda', 'yamaha', 'suzuki']motor.remove('ducati')print(motor) [&#39;honda&#39;, &#39;yamaha&#39;, &#39;suzuki&#39;] motor = ['ducati', 'honda', 'yamaha', 'suzuki']too_expensive = 'ducati'motor.remove(too_expensive)print(motor)print(\"\\nA \" + too_expensive.title() + \" is too expensive for me.\") [&#39;honda&#39;, &#39;yamaha&#39;, &#39;suzuki&#39;] A Ducati is too expensive for me. 008 Arrange Lists&emsp;&emsp;To Sort Permanently cars = ['bmw', 'audi', 'toyota', 'subaru']cars.sort()print(cars) [&#39;audi&#39;, &#39;bmw&#39;, &#39;subaru&#39;, &#39;toyota&#39;] cars = ['bmw', 'audi', 'toyota', 'subaru']cars.sort(reverse = True)print(cars) [&#39;toyota&#39;, &#39;subaru&#39;, &#39;bmw&#39;, &#39;audi&#39;] &emsp;&emsp;To Sort Temporarily cars = ['bmw', 'audi', 'toyota', 'subaru']print(cars)print(sorted(cars))print(cars) [&#39;bmw&#39;, &#39;audi&#39;, &#39;toyota&#39;, &#39;subaru&#39;] [&#39;audi&#39;, &#39;bmw&#39;, &#39;subaru&#39;, &#39;toyota&#39;] [&#39;bmw&#39;, &#39;audi&#39;, &#39;toyota&#39;, &#39;subaru&#39;] &emsp;&emsp;To Reverse cars = ['bmw', 'audi', 'toyota', 'subaru']print(cars)cars.reverse() #don't forget the \"()\"!print(cars)cars.reverse()print(cars) [&#39;bmw&#39;, &#39;audi&#39;, &#39;toyota&#39;, &#39;subaru&#39;] [&#39;subaru&#39;, &#39;toyota&#39;, &#39;audi&#39;, &#39;bmw&#39;] [&#39;bmw&#39;, &#39;audi&#39;, &#39;toyota&#39;, &#39;subaru&#39;] &emsp;&emsp;To Confirm the Length cars = ['bmw', 'audi', 'toyota', 'subaru']len(cars) 4 Chapter 4 Operate the List001 For: Loopmagicians = ['alice', 'david', 'carolina']for magician in magicians: print(magician.title() + \", that was a great trick!\") Alice, that was a great trick! David, that was a great trick! Carolina, that was a great trick! magicians = ['alice', 'david', 'carolina']for magician in magicians: print(magician.title() + \", that was a great trick!\") print(\"I can't wait to see your next trick, \" + magician.title() + \".\\n\") Alice, that was a great trick! I can&#39;t wait to see your next trick, Alice. David, that was a great trick! I can&#39;t wait to see your next trick, David. Carolina, that was a great trick! I can&#39;t wait to see your next trick, Carolina. ​ magicians = ['alice', 'david', 'carolina']for magician in magicians: print(magician.title() + \", that was a great trick!\") print(\"I can't wait to see your next trick, \" + magician.title() + \".\\n\")print(\"Thank you, all!\") Alice, that was a great trick! I can&#39;t wait to see your next trick, Alice. David, that was a great trick! I can&#39;t wait to see your next trick, David. Carolina, that was a great trick! I can&#39;t wait to see your next trick, Carolina. Thank you, all! &emsp;&emsp;As you can see, indent is very important in Python. It can decide whether your program will be running properly. magicians = ['alice', 'david', 'carolina']for magician in magicians:print(magician.title() + \", that was a great trick!\") File &quot;&lt;ipython-input-32-f0b382b2b777&gt;&quot;, line 3 print(magician.title() + &quot;, that was a great trick!&quot;) ^ IndentationError: expected an indented block &emsp;&emsp;See? An error occured when you don’t indent the code! msg = \"hello\" print(msg) &emsp;&emsp;Errors also occur when there’s an unnecessary indent! &emsp;&emsp;And don’t forget the : after each “for”! 002 Use A Number As the Loop Control Variablefor value in range(1,6): print(value) &emsp;&emsp;range() stops when value reaches 6, which means after 5 is printed and value has been 6, the program will stop. &emsp;&emsp;And range() has other ways to use. numbers = list(range(1,6))print(numbers) odd_numbers = list(range(1,11,2))print(odd_numbers) squares = []for value in range(1,11): squares.append(value**2)print(squares) &emsp;&emsp;Below are three functions in Python which can be used to do some simple operations to a list made up of numbers. digits = list(range(0,10))min(digits) max(digits) sum(digits) &emsp;&emsp;Now let’s look at another way to create a list made up of squares! squares = [value**2 for value in range(1,11)]print(squares) 003 Slicesplayers = ['charles', 'martina', 'micheal', 'florence', 'eli']print(players[0:3]) players = ['charles', 'martina', 'micheal', 'florence', 'eli']print(players[1:4]) players = ['charles', 'martina', 'micheal', 'florence', 'eli']print(players[:4]) players = ['charles', 'martina', 'micheal', 'florence', 'eli']print(players[2:]) players = ['charles', 'martina', 'micheal', 'florence', 'eli']print(players[-3:]) players = ['charles', 'martina', 'micheal', 'florence', 'eli']print(\"Here are the first three players on my team:\")for player in players[:3]: print(player.title()) my_foods = ['pizza', 'falafel', 'carrot cake']friend_foods = my_foodsprint(\"My favorite foods are:\")print(my_foods)print(\"\\nMyfriend's favorite foods are:\")print(friend_foods) my_foods = ['pizza', 'falafel', 'carrot cake']friend_foods = my_foods[:]print(\"My favorite foods are:\")print(my_foods)print(\"\\nMyfriend's favorite foods are:\")print(friend_foods) my_foods = ['pizza', 'falafel', 'carrot cake']friend_foods = my_foods[:]my_foods.append('cannoli')friend_foods.append('ice cream')print(\"My favorite foods are:\")print(my_foods)print(\"\\nMyfriend's favorite foods are:\")print(friend_foods) my_foods = ['pizza', 'falafel', 'carrot cake']friend_foods = my_foods# Not Workablemy_foods.append('cannoli')friend_foods.append('ice cream')print(\"My favorite foods are:\")print(my_foods)print(\"\\nMyfriend's favorite foods are:\")print(friend_foods) &emsp;&emsp;Mind the tiny difference between the two codes.&emsp;&emsp;Though they look similar, the results are totally different! 004 Tupledimensions = (200, 50)print(dimensions[0])print(dimensions[1]) &emsp;&emsp;Edting the elements in a tuple is illegal! dimensions = (200, 50)dimensions[0] = 250 dimensions = (200, 50)for dimension in dimensions: print(dimension) 200 50 &emsp;&emsp;However, assigning the whole tuple is allowed! dimensions = (200, 50)print(\"origin:\")print(dimensions)dimensions = (400, 100)print(\"modified:\")print(dimensions) origin: (200, 50) modified: (400, 100) 005 PEP 8&emsp;&emsp;Check Here for more details.&emsp;&emsp;https://www.python.org/dev/peps/pep-0008/ Chapter 5 If Statement001 Simple Examplecars = ['audi', 'bmw', 'subaru', 'toyota']for car in cars: if car == 'bmw': print(car.upper()) else: print(car.title()) Audi BMW Subaru Toyota 002 Condition Testingcar = 'bmw'car == 'bmw' True car = 'bmw'car == 'audi' False car = 'Audi'car == 'audi' False car = 'Audi'car.lower() == 'audi' True car = 'Audi'car.lower() == 'audi'car &#39;Audi&#39; car = 'Audi'car.lower() == 'auDi'.lower() True &emsp;&emsp;!= is availiable, too! str1 = 'hello'str2 = 'hel'str1 != str2 True &emsp;&emsp;Numbers are workable, too! age = 18age == 18 True age &gt;= 18 True age &gt; 17 True age &gt; 16 and age &lt; 19 True (age &gt; 16) and (age &lt; 19) True (age &lt; 16) or (age != 17) True requested_toppings = ['mushrooms', 'onions', 'pineapple']'mushrooms' in requested_toppings True 'apple' in requested_toppings False bool1 = Truebool2 = Falsebool1 and bool2 False 003 If Statementage = 12if age &lt; 4: print(1)elif age &lt; 18: print(2)elif age &gt; 65: print(3)else: print(4) 2 age = 1if age &lt; 4: print(1)elif age &lt; 18: print(2)elif age &gt; 65: print(3) 1 004 Combinationrequested_toppings = ['mushrooms', 'green peppers', 'extra cheese']for requested_topping in requested_toppings: if requested_topping == 'green peppers': print(\"Sorry, we ran out of \" + requested_topping + \".\") else: print(\"Adding \" + requested_topping + \".\")print(\"Finished!\") Adding mushrooms. Sorry, we ran out of green peppers. Adding extra cheese. Finished! requested_toppings = []if requested_toppings: for requested_topping in requested_toppings: if requested_topping == 'green peppers': print(\"Sorry, we ran out of \" + requested_topping + \".\") else: print(\"Adding \" + requested_topping + \".\")else: print(\"You want a plain pizza?\") You want a plain pizza? available_toppings = ['mushrooms', 'extra cheese']requested_toppings = ['mushrooms', 'green peppers', 'extra cheese']if requested_toppings: for requested_topping in requested_toppings: if requested_topping in available_toppings: print(\"Adding \" + requested_topping + \".\") else: print(\"Sorry, we ran out of \" + requested_topping + \".\")else: print(\"You want a plain pizza?\")print(\"\\nFinished!\") Adding mushrooms. Sorry, we ran out of green peppers. Adding extra cheese. Finished! Chapter 6 Dictionary001 A Simple Examplealien_0 = &#123;'color' : 'green', 'points' : 5&#125;print(alien_0['color'])print(alien_0['points']) green 5 &emsp;&emsp;A dictionary is a series of “key = value”.&emsp;&emsp;In this case, ‘color’ and ‘points’ are two keys, and ‘green’ and 5 are two values. alien_0 = &#123;'color' : 'green', 'points' : 5&#125;color_0 = alien_0['color']print('The color is ' + color_0 + '.') The color is green. alien_0 = &#123;'color' : 'green', 'points' : 5&#125;print('The color is ' + alien_0['color'] + '.') The color is green. alien_0 = &#123;'color' : 'green', 'points' : 5&#125;print(alien_0)alien_0['x_position'] = 0alien_0['y_position'] = 25print(alien_0) {&#39;color&#39;: &#39;green&#39;, &#39;points&#39;: 5} {&#39;color&#39;: &#39;green&#39;, &#39;points&#39;: 5, &#39;x_position&#39;: 0, &#39;y_position&#39;: 25} &emsp;&emsp;You can create an empty dictionary for convenience, just like you have done for lists. alien_0 = &#123;&#125;print(alien_0)alien_0['color'] = 'green'alien_0['points'] = 5print(alien_0) {} {&#39;color&#39;: &#39;green&#39;, &#39;points&#39;: 5} 002 Modification and Deletionalien_0 = &#123;'color' : 'green', 'points' : 5&#125;print(alien_0)alien_0['color'] = 'yellow'print(alien_0) {&#39;color&#39;: &#39;green&#39;, &#39;points&#39;: 5} {&#39;color&#39;: &#39;yellow&#39;, &#39;points&#39;: 5} alien_0 = &#123;'color' : 'green', 'points' : 5&#125;print(alien_0)del alien_0['points']print(alien_0) {&#39;color&#39;: &#39;green&#39;, &#39;points&#39;: 5} {&#39;color&#39;: &#39;green&#39;} &emsp;&emsp;Code Standards For Long Statements favorite_languages = &#123; 'jen' : 'python', 'sarah' : 'C', 'edward' : 'ruby', 'phil' : 'python',&#125;print(\"Sarah's favorite language is \" + favorite_languages['sarah'].title() + '.') Sarah&#39;s favorite language is C. 003 Traverse A Dictionaryuser_0 = &#123; 'username' : 'efermi', 'first' : 'enrico', 'last' : 'fermi', &#125;for key, value in user_0.items(): print(\"\\nKey: \" + key) print(\"Value: \" + value) Key: username Value: efermi Key: first Value: enrico Key: last Value: fermi favorite_languages = &#123; 'jen' : 'python', 'sarah' : 'C', 'edward' : 'ruby', 'phil' : 'python', &#125;for name, language in favorite_languages.items(): print(name.title() + \"'s favortie language is \" + language.title() + \".\") Jen&#39;s favortie language is Python. Sarah&#39;s favortie language is C. Edward&#39;s favortie language is Ruby. Phil&#39;s favortie language is Python. favorite_languages = &#123; 'jen' : 'python', 'sarah' : 'C', 'edward' : 'ruby', 'phil' : 'python', &#125;for name in favorite_languages.keys(): print(name.title()) Jen Sarah Edward Phil &emsp;&emsp;In fact, .keys() can be omitted. favorite_languages = &#123; 'jen' : 'python', 'sarah' : 'C', 'edward' : 'ruby', 'phil' : 'python', &#125;for name in favorite_languages: #mind here! print(name.title()) Jen Sarah Edward Phil favorite_languages = &#123; 'jen' : 'python', 'sarah' : 'C', 'edward' : 'ruby', 'phil' : 'python', &#125;friends = ['phil', 'sarah']for name in favorite_languages.keys(): print(name.title()) if name in friends: print(\" Hi! \" + name.title() + \", I see your favorite language is \" + favorite_languages[name].title() + \"!\") Jen Sarah Hi! Sarah, I see your favorite language is C! Edward Phil Hi! Phil, I see your favorite language is Python! &emsp;&emsp;This is how .keys() actually works. favorite_languages = &#123; 'jen' : 'python', 'sarah' : 'C', 'edward' : 'ruby', 'phil' : 'python', &#125;favorite_languages.keys() dict_keys([&#39;jen&#39;, &#39;sarah&#39;, &#39;edward&#39;, &#39;phil&#39;]) favorite_languages = &#123; 'jen' : 'python', 'sarah' : 'C', 'edward' : 'ruby', 'phil' : 'python', &#125;if 'erin' not in favorite_languages.keys(): print(\"Erin, please take our poll!\") Erin, please take our poll! favorite_languages = &#123; 'jen' : 'python', 'sarah' : 'C', 'edward' : 'ruby', 'phil' : 'python', &#125;for name in sorted(favorite_languages.keys()): print(name.title()) Edward Jen Phil Sarah favorite_languages = &#123; 'jen' : 'python', 'sarah' : 'C', 'edward' : 'ruby', 'phil' : 'python', &#125;favorite_languages.values() dict_values([&#39;python&#39;, &#39;C&#39;, &#39;ruby&#39;, &#39;python&#39;]) favorite_languages = &#123; 'jen' : 'python', 'sarah' : 'C', 'edward' : 'ruby', 'phil' : 'python', &#125;set(favorite_languages.values()) {&#39;C&#39;, &#39;python&#39;, &#39;ruby&#39;} &emsp;&emsp;This will remove the repeated values! 004 NestDictionaries in A Listaliens = []for alien_number in range(30): new_alien = &#123;'color': 'green', 'points': 5, 'speed': 'slow'&#125; aliens.append(new_alien)for alien in aliens[0:3]: if alien['color'] == 'green': alien['color'] = 'yellow' alien['speed'] = 'medium' alien['points'] = 10 elif alien['color'] == 'yellow': alien['color'] = 'res' alien['speed'] = 'fast' alien['points'] = 15 for alien in aliens[:5]: print(alien)print(\"...\")print(\"Total number of aliens: \" + str(len(aliens))) {&#39;color&#39;: &#39;yellow&#39;, &#39;points&#39;: 10, &#39;speed&#39;: &#39;medium&#39;} {&#39;color&#39;: &#39;yellow&#39;, &#39;points&#39;: 10, &#39;speed&#39;: &#39;medium&#39;} {&#39;color&#39;: &#39;yellow&#39;, &#39;points&#39;: 10, &#39;speed&#39;: &#39;medium&#39;} {&#39;color&#39;: &#39;green&#39;, &#39;points&#39;: 5, &#39;speed&#39;: &#39;slow&#39;} {&#39;color&#39;: &#39;green&#39;, &#39;points&#39;: 5, &#39;speed&#39;: &#39;slow&#39;} ... Total number of aliens: 30 Lists in A Dictionaryfavorite_languages = &#123; 'jen' : ['python', 'ruby'], 'sarah' : ['C'], 'edward' : ['ruby', 'go'], 'phil' : ['python', 'haskell'], &#125;for name, language in favorite_languages.items(): if len(language) == 1: print(\"\\n\" + name.title() + \"'s favorite language is \" + language[0].title()) else: print(\"\\n\" + name.title() + \"'s favorite languages are:\") for language in languages: print(\"\\t\" + language.title()) Jen&#39;s favorite languages are: Python Haskell Sarah&#39;s favorite language is C Edward&#39;s favorite languages are: Python Haskell Phil&#39;s favorite languages are: Python Haskell users = &#123; 'aeinsein' : &#123; 'first' : 'albert', 'last' : 'einstein', 'location' : 'princeton', &#125;, 'mcurie':&#123; 'first' : 'marie', 'last' : 'curie', 'location' : 'paris', &#125;, &#125;for username, user_info in users.items(): print(\"\\nUsername: \" + username) full_name = user_info['first'] + \" \" + user_info['last'] location = user_info['location'] print(\"\\tFull name:\" + full_name.title()) print(\"\\tLocation: \" + location.title()) Username: aeinsein Full name:Albert Einstein Location: Princeton Username: mcurie Full name:Marie Curie Location: Paris Chapter 7 Input and While Loop001 input() ？ Try int()msg = input(\"Tell me sth:\")print(msg) Tell me sth:test test msg0 = \"hello \"msg0 += \"\\ninput sth: \"msg1 = input(msg0)print(msg1) hello input sth: test1 test1 &emsp;&emsp;But, how to input a number? age = input(\"your age\")age your age18 &#39;18&#39; age = input(\"your age\")age &gt;= 18 your age18 --------------------------------------------------------------------------- TypeError Traceback (most recent call last) &lt;ipython-input-9-74683d3f63a8&gt; in &lt;module&gt; 1 age = input(&quot;your age&quot;) ----&gt; 2 age &gt;= 18 TypeError: &#39;&gt;=&#39; not supported between instances of &#39;str&#39; and &#39;int&#39; age1 = input(age1)age1 --------------------------------------------------------------------------- NameError Traceback (most recent call last) &lt;ipython-input-7-b4864473f466&gt; in &lt;module&gt; ----&gt; 1 age1 = input(age1) 2 age1 NameError: name &#39;age1&#39; is not defined &emsp;&emsp;Above is just a silly test out of my curiosity. age = input(\"your age\")age = int(age)age &gt;= 18 your age18 True Mod %4 % 3 1 num = input()num = int(num)if num % 2 == 0: print(\"\\nThe number \" + num + \" is even.\")else: print(\"\\nThe number \" + num + \" is odd.\") 100 --------------------------------------------------------------------------- TypeError Traceback (most recent call last) &lt;ipython-input-13-2b870bf3f31d&gt; in &lt;module&gt; 3 4 if num % 2 == 0: ----&gt; 5 print(&quot;\\nThe number &quot; + num + &quot; is even.&quot;) 6 else: 7 print(&quot;\\nThe number &quot; + num + &quot; is odd.&quot;) TypeError: must be str, not int num = input()num = int(num)if num % 2 == 0: print(\"\\nThe number \" + str(num) + \" is even.\")else: print(\"\\nThe number \" + str(num) + \" is odd.\") 100 The number 100 is even. &emsp;&emsp;Bear in mind that str() is necessary when inserting a number into a string. 002 Whilecnt = 1while cnt &lt;= 5: print(cnt) cnt += 1 1 2 3 4 5 &emsp;&emsp;cnt++ is illegal in Python! msg = \"\"while msg != \"quit\": msg = input(msg) if msg != \"quit\": print(msg + \"\\n\") 666 666 666quit active = Truewhile active: msg = input() if msg == \"quit\": active = False else: print(msg) 666 666 quit while True: msg = input() if msg == \"quit\": break else: print(msg) 666 666 quit i = 0while i &lt; 10: i += 1 if i % 2 == 0: continue print(i) 1 3 5 7 9 i = 1while i &lt; 10: print(i) &emsp;&emsp;Above is a endless loop! 003 While &amp; List &amp; Dictionaryunconfirmed_users = ['alice', 'brain', 'candace']confirmed_users = []while unconfirmed_users: current_user = unconfirmed_users.pop() print(\"Verifying user: \" + current_user.title()) confirmed_users.append(current_user) print(\"\\nThe following users have been confirmed:\")for confirmed_user in confirmed_users: print(confirmed_user.title()) Verifying user: Candace Verifying user: Brain Verifying user: Alice The following users have been confirmed: Candace Brain Alice pets = ['dog', 'cat', 'dog', 'goldfish', 'cat', 'rabbit', 'cat']print(pets)while 'cat' in pets: pets.remove('cat') print(pets) [&#39;dog&#39;, &#39;cat&#39;, &#39;dog&#39;, &#39;goldfish&#39;, &#39;cat&#39;, &#39;rabbit&#39;, &#39;cat&#39;] [&#39;dog&#39;, &#39;dog&#39;, &#39;goldfish&#39;, &#39;rabbit&#39;] responses = &#123;&#125;polling_active = Truewhile polling_active: name = input(\"\\nWhat's your name? \") response = input(\"Which mountain would you like to climb someday? \") responses[name] = response repeat = input(\"Would you like to let another person respond? (yes/no)\") if repeat == 'no': polling_active = Falseprint(\"\\n--- Poll Results ---\")for name, response in responses.items(): print(name + \" would like to climb \" + response + '.') What&#39;s your name? 1 Which mountain would you like to climb someday? 1 Would you like to let another person respond? (yes/no)No What&#39;s your name? 2 Which mountain would you like to climb someday? 2 Would you like to let another person respond? (yes/no)no --- Poll Results --- 1 would like to climb 1. 2 would like to climb 2. Chapter 8 Function001 Define a functiondef greet_user(): print(\"Hello!\") greet_user() Hello! def greet_user(username): print(\"Hello, \" + username.title() + \"!\") greet_user(\"charlie\") Hello, Charlie! &emsp;&emsp;Mind the formal parameter and the actual parameter def describe_pet(animal_type, pet_name): print(\"\\nI have a \" + animal_type + \".\") print(\"My \" + animal_type + \"'s name is\" + pet_name.title() + \".\") describe_pet(\"hamster\", 'harry') I have a hamster. My hamster&#39;s name isHarry. def describe_pet(animal_type, pet_name): print(\"\\nI have a \" + animal_type + \".\") print(\"My \" + animal_type + \"'s name is\" + pet_name.title() + \".\") describe_pet(\"hamster\", 'harry')describe_pet(\"dog\", 'willie') I have a hamster. My hamster&#39;s name isHarry. I have a dog. My dog&#39;s name isWillie. def describe_pet(animal_type, pet_name): print(\"\\nI have a \" + animal_type + \".\") print(\"My \" + animal_type + \"'s name is\" + pet_name.title() + \".\") describe_pet(\"hamster\", 'harry')describe_pet('harry', \"hamster\")describe_pet(animal_type = 'hamster', pet_name = 'harry')describe_pet(pet_name = 'harry', animal_type = 'hamster') I have a hamster. My hamster&#39;s name isHarry. I have a harry. My harry&#39;s name isHamster. I have a hamster. My hamster&#39;s name isHarry. I have a hamster. My hamster&#39;s name isHarry. &emsp;&emsp;Mind the last two calling of the function describe_pet ! 002 Functions with default valuesdef describe_pet(pet_name, animal_type = 'dog'): print(\"\\nI have a \" + animal_type + \".\") print(\"My \" + animal_type + \"'s name is\" + pet_name.title() + \".\") describe_pet('harry', \"hamster\")describe_pet('willie') I have a hamster. My hamster&#39;s name isHarry. I have a dog. My dog&#39;s name isWillie. def describe_pet(animal_type = 'dog', pet_name): print(\"\\nI have a \" + animal_type + \".\") print(\"My \" + animal_type + \"'s name is\" + pet_name.title() + \".\") describe_pet(\"hamster\", 'harry')describe_pet('willie') File &quot;&lt;ipython-input-22-783719293d54&gt;&quot;, line 1 def describe_pet(animal_type = &#39;dog&#39;, pet_name): ^ SyntaxError: non-default argument follows default argument &emsp;&emsp;This time, an error occured! def describe_pet(animal_type = 'dog', pet_name): print(\"\\nI have a \" + animal_type + \".\") print(\"My \" + animal_type + \"'s name is\" + pet_name.title() + \".\") describe_pet(\"hamster\", 'harry')describe_pet(pet_name = 'willie') File &quot;&lt;ipython-input-23-697809b5a3b4&gt;&quot;, line 1 def describe_pet(animal_type = &#39;dog&#39;, pet_name): ^ SyntaxError: non-default argument follows default argument &emsp;&emsp;Another error! &emsp;&emsp;In Python, you have to put the non-default arguments before the default ones!!! 003 Return Valuedef get_full_name(first_name, second_name): full_name = first_name + ' ' + second_name return full_name.title()musician = get_full_name('jimi', 'hendrix')print(musician) Jimi Hendrix def get_formatted_name(first_name, last_name, middle_name=''): # Pay Attention! if middle_name: full_name = first_name + ' ' + middle_name + ' ' + last_name else: full_name = first_name + ' ' + last_name return full_name.title()musician = get_formatted_name('jimi', 'hendrix')print(musician)musician = get_formatted_name('john', 'hooker', 'lee')print(musician) Jimi Hendrix John Lee Hooker def build_person(first_name, last_name, age=''): person = &#123;'first': first_name, 'last': last_name&#125; if age: person['age'] = age return personmusician = build_person('jimi', 'hendrix')print(musician)musician = build_person('jimi', 'hendrix', 27)print(musician) {&#39;first&#39;: &#39;jimi&#39;, &#39;last&#39;: &#39;hendrix&#39;} {&#39;first&#39;: &#39;jimi&#39;, &#39;last&#39;: &#39;hendrix&#39;, &#39;age&#39;: 27} def get_full_name(first_name, second_name): full_name = first_name + ' ' + second_name return full_name.title()while True: print(\"\\nPlease tell me your name:\") print(\"(Enter 'q' to quit!)\") f_name = input(\"First name:\") if f_name == 'q': break; l_name = input(\"Last name:\") if l_name == 'q': break; formatted_name = get_full_name(f_name, l_name) print(\"\\nHello, \" + formatted_name + '!') Please tell me your name: (Enter &#39;q&#39; to quit!) First name:charlie Last name:jiang Hello, Charlie Jiang! Please tell me your name: (Enter &#39;q&#39; to quit!) First name:charlie Last name:jiang Hello, Charlie Jiang! Please tell me your name: (Enter &#39;q&#39; to quit!) First name:c Last name:q 004 Relay Listsdef greet_users(names): for name in names: msg = \"Hello, \" + name.title() + \"!\" print(msg) usernames = ['hannah', 'ty', 'margot']greet_users(usernames) Hello, Hannah! Hello, Ty! Hello, Margot! def print_models(unprinted_designs, completed_models): while unprinted_designs: current_design = unprinted_designs.pop() print(\"Printing: \" + current_design) completed_models.append(current_design) def show_completed_models(completed_models): print(\"\\nThe following models have been printed:\") for completed_model in completed_models: print(completed_model) unprinted_designs = ['iphone case', 'robot pendant', 'dodecahedron']completed_models = []print_models(unprinted_designs, completed_models)show_completed_models(completed_models)print(unprinted_designs) Printing: dodecahedron Printing: robot pendant Printing: iphone case The following models have been printed: dodecahedron robot pendant iphone case [] def print_models(unprinted_designs, completed_models): while unprinted_designs: current_design = unprinted_designs.pop() print(\"Printing: \" + current_design) completed_models.append(current_design) def show_completed_models(completed_models): print(\"\\nThe following models have been printed:\") for completed_model in completed_models: print(completed_model) unprinted_designs = ['iphone case', 'robot pendant', 'dodecahedron']completed_models = []print_models(unprinted_designs[:], completed_models)show_completed_models(completed_models)print(unprinted_designs) Printing: dodecahedron Printing: robot pendant Printing: iphone case The following models have been printed: dodecahedron robot pendant iphone case [&#39;iphone case&#39;, &#39;robot pendant&#39;, &#39;dodecahedron&#39;] &emsp;&emsp;The second version of this programme conveys a copy of a list! 005 Relay as many actual parameters as you like!def make_pizza(*toppings): print(\"\\nMaking a pizza with the following toppings:\") for topping in toppings: print(\"- \" + topping) make_pizza('pepperoni')make_pizza('mushrooms', 'green peppers', 'extra cheese') Making a pizza with the following toppings: - pepperoni Making a pizza with the following toppings: - mushrooms - green peppers - extra cheese &emsp;&emsp;* let Python create a tuple that contains the actual parameters you relayed, no matter how many actual parameters you relayed to the function. def make_pizza(size, *toppings): print(\"\\nMaking a \" + str(size) + \"-inch pizza with the following toppings:\") for topping in toppings: print(\"- \" + topping) make_pizza(16, 'pepperoni')make_pizza(12, 'mushrooms', 'green peppers', 'extra cheese') Making a 16-inch pizza with the following toppings: - pepperoni Making a 12-inch pizza with the following toppings: - mushrooms - green peppers - extra cheese def build_profile(first, last, **user_info): profile = &#123;&#125; profile['first_name'] = first profile['last_name'] = last for key,value in user_info.items(): profile[key] = value return profileuser_profile = build_profile('albert', 'einstein', location = 'princeton', field = 'physics')print(user_profile) {&#39;first_name&#39;: &#39;albert&#39;, &#39;last_name&#39;: &#39;einstein&#39;, &#39;location&#39;: &#39;princeton&#39;, &#39;field&#39;: &#39;physics&#39;} &emsp;&emsp;** let Python create a dictionary that contains the keys and values you relayed, no matter how many pairs you have relayed to the function. 006 Import&emsp;&emsp;Due to the difficulty of using import in notebook. I’ll practice this part in sublime text 3. 007 PEP8, again!def function_name(parameter_0, parameter_1='default_value')function_name(value_0, parameter_1='value_1')def function_name( parameter_0, parameter_1, parameter_2, parameter_3, parameter_4, parameter_5): function body... Chapter 9 Class001 Introduction to Classclass Dog(): def __init__(self, name, age): self.name = name self.age = age def sit(self): print(self.name.title() + \" is now sitting.\") def roll_over(self): print(self.name.title() + \" rolled over!\") my_dog = Dog('willie', 6)print(\"name: \" + my_dog.name.title())print(\"age: \" + str(my_dog.age)) name: Willie age: 6 my_dog = Dog('willie', 6)print(\"name: \" + my_dog.name.title())print(\"age: \" + str(my_dog.age)) name: Willie age: 6 &emsp;&emsp;Mind that __init__ has two _s at each side! my_dog.sit() Willie is now sitting. my_dog.roll_over() Willie rolled over! your_dog = Dog('Lucy', 3)your_dog.name &#39;Lucy&#39; your_dog.age 3 your_dog.sit() Lucy is now sitting. 002 Use Class and Instancesclass Car(): def __init__(self, make, model, year): self.make = make self.model = model self.year = year self.odometer_reading = 0 def get_descriptive_name(self): long_name = str(self.year) + \" \" + self.make + \" \" + self.model return long_name.title() def read_odometer(self): print(\"This car has \" + str(self.odometer_reading) + \" miles on it.\") my_new_car = Car('audi', 'a4', 2016)print(my_new_car.get_descriptive_name())my_new_car.read_odometer() 2016 Audi A4 This car has 0 miles on it. &emsp;&emsp;Here are some ways to change properties. my_new_car.odometer_reading = 23my_new_car.read_odometer() This car has 23 miles on it. class Car(): def __init__(self, make, model, year): self.make = make self.model = model self.year = year self.odometer_reading = 0 def get_descriptive_name(self): long_name = str(self.year) + \" \" + self.make + \" \" + self.model return long_name.title() def read_odometer(self): print(\"This car has \" + str(self.odometer_reading) + \" miles on it.\") def update_odometer(self, mileage): if mileage &gt; self.odometer_reading: self.odometer_reading = mileage else: print(\"You can't roll back an odometer!\") my_new_car = Car('audi', 'a4', 2016)print(my_new_car.get_descriptive_name())my_new_car.read_odometer()my_new_car.update_odometer(23)my_new_car.read_odometer() 2016 Audi A4 This car has 0 miles on it. This car has 23 miles on it. my_new_car.update_odometer(46)my_new_car.read_odometer()my_new_car.update_odometer(23)my_new_car.read_odometer() This car has 46 miles on it. You can&#39;t roll back an odometer! This car has 46 miles on it. class Car(): def __init__(self, make, model, year): self.make = make self.model = model self.year = year self.odometer_reading = 0 def get_descriptive_name(self): long_name = str(self.year) + \" \" + self.make + \" \" + self.model return long_name.title() def read_odometer(self): print(\"This car has \" + str(self.odometer_reading) + \" miles on it.\") def update_odometer(self, mileage): if mileage &gt; self.odometer_reading: self.odometer_reading = mileage else: print(\"You can't roll back an odometer!\") def increment_odometer(self, miles): if miles &gt; 0: self.odometer_reading += miles else: print(\"You can't roll back an odometer!\") my_new_car = Car('audi', 'a4', 2016)print(my_new_car.get_descriptive_name())my_new_car.read_odometer()my_new_car.update_odometer(23)my_new_car.read_odometer()my_new_car.increment_odometer(100)my_new_car.read_odometer()my_new_car.increment_odometer(-100)my_new_car.read_odometer() 2016 Audi A4 This car has 0 miles on it. This car has 23 miles on it. This car has 123 miles on it. You can&#39;t roll back an odometer! This car has 123 miles on it. 003 Inheritanceclass Car(): def __init__(self, make, model, year): self.make = make self.model = model self.year = year self.odometer_reading = 0 def get_descriptive_name(self): long_name = str(self.year) + \" \" + self.make + \" \" + self.model return long_name.title() def read_odometer(self): print(\"This car has \" + str(self.odometer_reading) + \" miles on it.\") def update_odometer(self, mileage): if mileage &gt; self.odometer_reading: self.odometer_reading = mileage else: print(\"You can't roll back an odometer!\") def increment_odometer(self, miles): if miles &gt; 0: self.odometer_reading += miles else: print(\"You can't roll back an odometer!\") def fill_gas_tank(self): print(\"Filled!\") class ElectricCar(Car): def __init__(self, make, model, year): super().__init__(make, model, year) self.battery_size = 70 def describe_battery(self): print(\"This car has a \" + str(self.battery_size) + \"-kWh battery.\") def fill_gas_tank(self): print(\"This car doesn't need a gas tank!\") my_tesla = ElectricCar('tesla', 'model s', 2016)print(my_tesla.get_descriptive_name())my_tesla.describe_battery()my_tesla.fill_gas_tank() 2016 Tesla Model S This car has a 70-kWh battery. This car doesn&#39;t need a gas tank! &emsp;&emsp;Don’t forget self !!! class Car(): def __init__(self, make, model, year): self.make = make self.model = model self.year = year self.odometer_reading = 0 def get_descriptive_name(self): long_name = str(self.year) + \" \" + self.make + \" \" + self.model return long_name.title() def read_odometer(self): print(\"This car has \" + str(self.odometer_reading) + \" miles on it.\") def update_odometer(self, mileage): if mileage &gt; self.odometer_reading: self.odometer_reading = mileage else: print(\"You can't roll back an odometer!\") def increment_odometer(self, miles): if miles &gt; 0: self.odometer_reading += miles else: print(\"You can't roll back an odometer!\") def fill_gas_tank(self): print(\"Filled!\") class Battery(): def __init__(self, battery_size=70): self.battery_size = battery_size def describe_battery(self): print(\"This car has a \" + str(self.battery_size) + \"-kWh battery.\") def get_range(self): if self.battery_size == 70: range = 240 elif self.battery_size == 85: range = 270 message = \"This car can go approximately \" + str(range) message += \" miles on a full charge.\" print(message) class ElectricCar(Car): def __init__(self, make, model, year): super().__init__(make, model, year) self.battery = Battery() def fill_gas_tank(self): print(\"This car doesn't need a gas tank!\") my_tesla = ElectricCar('tesla', 'model s', 2016)print(my_tesla.get_descriptive_name())my_tesla.battery.describe_battery()my_tesla.battery.get_range() 2016 Tesla Model S This car has a 70-kWh battery. This car can go approximately 240 miles on a full charge. 004 Import Class&emsp;&emsp;Similar to import functions. 005 Python Standard Libraryfrom collections import OrderedDictfavorite_languages = OrderedDict()favorite_languages['jen'] = 'python'favorite_languages['sarah'] = 'c'favorite_languages['edward'] = 'ruby'favorite_languages['phil'] = 'python'for name, language in favorite_languages.items(): print(name.title() + \"'s favorite language is \" + language.title() + \".\") Jen&#39;s favorite language is Python. Sarah&#39;s favorite language is C. Edward&#39;s favorite language is Ruby. Phil&#39;s favorite language is Python.","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://ncj.wiki/tags/Python/"},{"name":"Learning Notes","slug":"Learning-Notes","permalink":"https://ncj.wiki/tags/Learning-Notes/"}]},{"title":"2018年终回顾","slug":"2018-12-31_2018","date":"2018-12-31T09:36:06.000Z","updated":"2019-09-05T13:38:45.729Z","comments":true,"path":"2018/12/31/2018-12-31_2018/","link":"","permalink":"https://ncj.wiki/2018/12/31/2018-12-31_2018/","excerpt":"","text":"function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById(\"enc_error\").innerHTML = \"password error!\" }; function decrypt() { var passwd = document.getElementById(\"enc_pwd_input\").value; console.log(passwd); doDecrypt(passwd, onError); }","categories":[],"tags":[{"name":"Thoughts","slug":"Thoughts","permalink":"https://ncj.wiki/tags/Thoughts/"}]},{"title":"Thoughts after MSC Competition","slug":"2018-12-22_Thoughts-after-MSC-Competition","date":"2018-12-22T14:21:43.000Z","updated":"2019-09-05T13:38:45.729Z","comments":true,"path":"2018/12/22/2018-12-22_Thoughts-after-MSC-Competition/","link":"","permalink":"https://ncj.wiki/2018/12/22/2018-12-22_Thoughts-after-MSC-Competition/","excerpt":"","text":"&emsp;&emsp;After one online pre-competition (Let’s just call it that) and an offline final, the 2018 MSC C Language Programming Competition has finally ended. It’s really exciting for me, this is the very first competition I attended in college and it is also the first programming competition I attended. The result, as I had posted earlier on the social media, is neither bad nor good. I didn’t pay much attention to the rank. Instead, I think focusing more on the problems and the interesting algorithms is much more important, you know, some solutions to these problems are really amazing! Some problems can be solved really artfully, like the one concerned with possibility. So I’d like to share them with you, but not here, I’ll write about them in the column about amazing algorithms in the next year. &emsp;&emsp;Beside the realization of how interesting an algorithm can be, the competition also showed how excellent others can be. The best competitor gained 520 in all, but I only got 250. It’s lucky to have this kind of excellent student in my school, which symbolizes the strength of my school, especially its strength in Computer Science, my major. &emsp;&emsp;I know I still have to work hard to narrow the gap between me and the top ones, but I’m not afraid. Started to learn programming in summer, it’s almost half a year. The programs I write becomes longer and longer, but my interest grows stronger and stronger. The harder the problems are, the more they appeals to me. The more sophisticated the codes are, the more I enjoy them. I’m assured that I really love the path I chose. &emsp;&emsp;Already late at night, so much for today. See you in the next posts.","categories":[],"tags":[{"name":"Thoughts","slug":"Thoughts","permalink":"https://ncj.wiki/tags/Thoughts/"}]}]}